// ingore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_name

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for Neutron's Elemental
///
class NeutronElemental {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NeutronElemental(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NeutronElemental.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// nt_type_argument_get:
  /// @arguments: A list of %NtTypeArgument
  /// @name: The name of the argument to get
  /// @default_value: The value to return if @arguments does not contain @name
  ///
  /// Gets the argument as defined by @name in @arguments.
  /// If @name is not in @arguments, then return @default_value.
  ///
  /// Returns: An %NtValue of either an %NtTypeArgument value or @default_value.
  NtValue nt_type_argument_get(
    ffi.Pointer<NtTypeArgument> arguments,
    ffi.Pointer<ffi.Char> name,
    NtValue default_value,
  ) {
    return _nt_type_argument_get(
      arguments,
      name,
      default_value,
    );
  }

  late final _nt_type_argument_getPtr = _lookup<
      ffi.NativeFunction<
          NtValue Function(ffi.Pointer<NtTypeArgument>, ffi.Pointer<ffi.Char>,
              NtValue)>>('nt_type_argument_get');
  late final _nt_type_argument_get = _nt_type_argument_getPtr.asFunction<
      NtValue Function(
          ffi.Pointer<NtTypeArgument>, ffi.Pointer<ffi.Char>, NtValue)>();

  /// nt_type_register:
  /// @info: The %NtTypeInfo for the new type
  ///
  /// Register a new type
  ///
  /// Returns: The %NtType ID of the new type
  int nt_type_register(
    ffi.Pointer<NtTypeInfo> info,
  ) {
    return _nt_type_register(
      info,
    );
  }

  late final _nt_type_registerPtr =
      _lookup<ffi.NativeFunction<NtType Function(ffi.Pointer<NtTypeInfo>)>>(
          'nt_type_register');
  late final _nt_type_register =
      _nt_type_registerPtr.asFunction<int Function(ffi.Pointer<NtTypeInfo>)>();

  /// nt_type_register:
  /// @info: The %NtTypeInfo to unregister
  ///
  /// Unregisters a type
  void nt_type_unregister(
    ffi.Pointer<NtTypeInfo> info,
  ) {
    return _nt_type_unregister(
      info,
    );
  }

  late final _nt_type_unregisterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtTypeInfo>)>>(
          'nt_type_unregister');
  late final _nt_type_unregister = _nt_type_unregisterPtr
      .asFunction<void Function(ffi.Pointer<NtTypeInfo>)>();

  /// nt_type_isof:
  /// @type: The type to check
  /// @base: The base type to look for
  ///
  /// Checks whether or not @base is extended in @type.
  ///
  /// Returns: If %true then @type extends @base, otherwise %false is returned.
  bool nt_type_isof(
    int type,
    int base,
  ) {
    return _nt_type_isof(
      type,
      base,
    );
  }

  late final _nt_type_isofPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(NtType, NtType)>>(
          'nt_type_isof');
  late final _nt_type_isof =
      _nt_type_isofPtr.asFunction<bool Function(int, int)>();

  /// nt_type_info_from_type:
  /// @type: The %NtType ID
  ///
  /// Get type information from a type ID
  /// Returns: The type information for @type.
  ffi.Pointer<NtTypeInfo> nt_type_info_from_type(
    int type,
  ) {
    return _nt_type_info_from_type(
      type,
    );
  }

  late final _nt_type_info_from_typePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtTypeInfo> Function(NtType)>>(
          'nt_type_info_from_type');
  late final _nt_type_info_from_type = _nt_type_info_from_typePtr
      .asFunction<ffi.Pointer<NtTypeInfo> Function(int)>();

  /// nt_type_info_get_total_size:
  /// @info: The type info
  ///
  /// Returns: The total size of the type instance.
  int nt_type_info_get_total_size(
    ffi.Pointer<NtTypeInfo> info,
  ) {
    return _nt_type_info_get_total_size(
      info,
    );
  }

  late final _nt_type_info_get_total_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<NtTypeInfo>)>>(
          'nt_type_info_get_total_size');
  late final _nt_type_info_get_total_size = _nt_type_info_get_total_sizePtr
      .asFunction<int Function(ffi.Pointer<NtTypeInfo>)>();

  /// nt_type_instance_new:
  /// @type: The %NtType ID to create a new instance of
  /// @arguments: The argument to pass
  ///
  /// Constructs a new type instance.
  ///
  /// Returns: The new instance of @type
  ffi.Pointer<NtTypeInstance> nt_type_instance_new(
    int type,
    ffi.Pointer<NtTypeArgument> arguments,
  ) {
    return _nt_type_instance_new(
      type,
      arguments,
    );
  }

  late final _nt_type_instance_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtTypeInstance> Function(
              NtType, ffi.Pointer<NtTypeArgument>)>>('nt_type_instance_new');
  late final _nt_type_instance_new = _nt_type_instance_newPtr.asFunction<
      ffi.Pointer<NtTypeInstance> Function(int, ffi.Pointer<NtTypeArgument>)>();

  /// nt_type_instance_get_data:
  /// @instance: The type instance to get data for
  /// @type: The type in @instance to look for
  ///
  /// Gets the instance of type inside of the parent instance
  ///
  /// Returns: A pointer to where @type's instance data begins at.
  ffi.Pointer<NtTypeInstance> nt_type_instance_get_data(
    ffi.Pointer<NtTypeInstance> instance,
    int type,
  ) {
    return _nt_type_instance_get_data(
      instance,
      type,
    );
  }

  late final _nt_type_instance_get_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtTypeInstance> Function(ffi.Pointer<NtTypeInstance>,
              NtType)>>('nt_type_instance_get_data');
  late final _nt_type_instance_get_data =
      _nt_type_instance_get_dataPtr.asFunction<
          ffi.Pointer<NtTypeInstance> Function(
              ffi.Pointer<NtTypeInstance>, int)>();

  /// nt_type_instance_ref:
  /// @instance: The type instance to reference
  ///
  /// Increases the ref_count of the type instance
  ffi.Pointer<NtTypeInstance> nt_type_instance_ref(
    ffi.Pointer<NtTypeInstance> instance,
  ) {
    return _nt_type_instance_ref(
      instance,
    );
  }

  late final _nt_type_instance_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtTypeInstance> Function(
              ffi.Pointer<NtTypeInstance>)>>('nt_type_instance_ref');
  late final _nt_type_instance_ref = _nt_type_instance_refPtr.asFunction<
      ffi.Pointer<NtTypeInstance> Function(ffi.Pointer<NtTypeInstance>)>();

  /// nt_type_instance_unref:
  /// @instance: The type instance to unreference
  ///
  /// Decreases the reference count of the type instance.
  /// If the reference count is zero then the type instance is destroyed.
  void nt_type_instance_unref(
    ffi.Pointer<NtTypeInstance> instance,
  ) {
    return _nt_type_instance_unref(
      instance,
    );
  }

  late final _nt_type_instance_unrefPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtTypeInstance>)>>(
      'nt_type_instance_unref');
  late final _nt_type_instance_unref = _nt_type_instance_unrefPtr
      .asFunction<void Function(ffi.Pointer<NtTypeInstance>)>();

  late final ffi.Pointer<ffi.Size> _NT_BACKTRACE_SIZE =
      _lookup<ffi.Size>('NT_BACKTRACE_SIZE');

  int get NT_BACKTRACE_SIZE => _NT_BACKTRACE_SIZE.value;

  set NT_BACKTRACE_SIZE(int value) => _NT_BACKTRACE_SIZE.value = value;

  ffi.Pointer<NtBacktrace> NT_BACKTRACE(
    ffi.Pointer<NtTypeInstance> instance,
  ) {
    return _NT_BACKTRACE(
      instance,
    );
  }

  late final _NT_BACKTRACEPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtBacktrace> Function(
              ffi.Pointer<NtTypeInstance>)>>('NT_BACKTRACE');
  late final _NT_BACKTRACE = _NT_BACKTRACEPtr.asFunction<
      ffi.Pointer<NtBacktrace> Function(ffi.Pointer<NtTypeInstance>)>();

  bool NT_IS_BACKTRACE(
    ffi.Pointer<NtBacktrace> self,
  ) {
    return _NT_IS_BACKTRACE(
      self,
    );
  }

  late final _NT_IS_BACKTRACEPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtBacktrace>)>>(
          'NT_IS_BACKTRACE');
  late final _NT_IS_BACKTRACE =
      _NT_IS_BACKTRACEPtr.asFunction<bool Function(ffi.Pointer<NtBacktrace>)>();

  int nt_backtrace_get_type() {
    return _nt_backtrace_get_type();
  }

  late final _nt_backtrace_get_typePtr =
      _lookup<ffi.NativeFunction<NtType Function()>>('nt_backtrace_get_type');
  late final _nt_backtrace_get_type =
      _nt_backtrace_get_typePtr.asFunction<int Function()>();

  /// nt_backtrace_new:
  ///
  /// Creates a new backtrace
  /// Returns: An empty backtrace
  ffi.Pointer<NtBacktrace> nt_backtrace_new() {
    return _nt_backtrace_new();
  }

  late final _nt_backtrace_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtBacktrace> Function()>>(
          'nt_backtrace_new');
  late final _nt_backtrace_new =
      _nt_backtrace_newPtr.asFunction<ffi.Pointer<NtBacktrace> Function()>();

  /// nt_backtrace_new_auto:
  ///
  /// Generates a backtrace automatically
  /// Returns: A new backtrace containing all of the entries
  ffi.Pointer<NtBacktrace> nt_backtrace_new_auto() {
    return _nt_backtrace_new_auto();
  }

  late final _nt_backtrace_new_autoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtBacktrace> Function()>>(
          'nt_backtrace_new_auto');
  late final _nt_backtrace_new_auto = _nt_backtrace_new_autoPtr
      .asFunction<ffi.Pointer<NtBacktrace> Function()>();

  /// nt_backtrace_push_full:
  /// @self: An instance of a backtrace
  /// @file: The source file
  /// @method: The method name
  /// @line: The line in the source file
  /// @address: The address of the method
  ///
  /// Pushes a new method call onto the trace, it is recommended to use %nt_backtrace_push
  void nt_backtrace_push_full(
    ffi.Pointer<NtBacktrace> self,
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> method,
    int line,
    ffi.Pointer<ffi.Void> address,
  ) {
    return _nt_backtrace_push_full(
      self,
      file,
      method,
      line,
      address,
    );
  }

  late final _nt_backtrace_push_fullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NtBacktrace>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('nt_backtrace_push_full');
  late final _nt_backtrace_push_full = _nt_backtrace_push_fullPtr.asFunction<
      void Function(ffi.Pointer<NtBacktrace>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Void>)>();

  /// nt_backtrace_pop:
  /// @self: An instance of a backtrace
  ///
  /// Pops the last backtrace entry off
  void nt_backtrace_pop(
    ffi.Pointer<NtBacktrace> self,
  ) {
    return _nt_backtrace_pop(
      self,
    );
  }

  late final _nt_backtrace_popPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtBacktrace>)>>(
          'nt_backtrace_pop');
  late final _nt_backtrace_pop = _nt_backtrace_popPtr
      .asFunction<void Function(ffi.Pointer<NtBacktrace>)>();

  late final ffi.Pointer<ffi.Size> _NT_ERROR_SIZE =
      _lookup<ffi.Size>('NT_ERROR_SIZE');

  int get NT_ERROR_SIZE => _NT_ERROR_SIZE.value;

  set NT_ERROR_SIZE(int value) => _NT_ERROR_SIZE.value = value;

  ffi.Pointer<NtError> NT_ERROR(
    ffi.Pointer<NtTypeInstance> instance,
  ) {
    return _NT_ERROR(
      instance,
    );
  }

  late final _NT_ERRORPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtError> Function(
              ffi.Pointer<NtTypeInstance>)>>('NT_ERROR');
  late final _NT_ERROR = _NT_ERRORPtr.asFunction<
      ffi.Pointer<NtError> Function(ffi.Pointer<NtTypeInstance>)>();

  bool NT_IS_ERROR(
    ffi.Pointer<NtError> self,
  ) {
    return _NT_IS_ERROR(
      self,
    );
  }

  late final _NT_IS_ERRORPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtError>)>>(
          'NT_IS_ERROR');
  late final _NT_IS_ERROR =
      _NT_IS_ERRORPtr.asFunction<bool Function(ffi.Pointer<NtError>)>();

  int nt_error_get_type() {
    return _nt_error_get_type();
  }

  late final _nt_error_get_typePtr =
      _lookup<ffi.NativeFunction<NtType Function()>>('nt_error_get_type');
  late final _nt_error_get_type =
      _nt_error_get_typePtr.asFunction<int Function()>();

  /// nt_error_new_full:
  /// @file: The file the error comes from
  /// @method: The method the error comes from
  /// @line: The line in the file the error comes from
  /// @message: The error message
  /// @backtrace: The backtrace of the error
  ///
  /// Fully creates a new error, it is recommended to use %nt_error_new
  ///
  /// Returns: A new error
  ffi.Pointer<NtError> nt_error_new_full(
    ffi.Pointer<ffi.Char> file,
    ffi.Pointer<ffi.Char> method,
    int line,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<NtBacktrace> backtrace,
  ) {
    return _nt_error_new_full(
      file,
      method,
      line,
      message,
      backtrace,
    );
  }

  late final _nt_error_new_fullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtError> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<NtBacktrace>)>>('nt_error_new_full');
  late final _nt_error_new_full = _nt_error_new_fullPtr.asFunction<
      ffi.Pointer<NtError> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<NtBacktrace>)>();

  late final ffi.Pointer<ffi.Size> _NT_LIST_SIZE =
      _lookup<ffi.Size>('NT_LIST_SIZE');

  int get NT_LIST_SIZE => _NT_LIST_SIZE.value;

  set NT_LIST_SIZE(int value) => _NT_LIST_SIZE.value = value;

  ffi.Pointer<NtList> NT_LIST(
    ffi.Pointer<NtTypeInstance> instance,
  ) {
    return _NT_LIST(
      instance,
    );
  }

  late final _NT_LISTPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtList> Function(
              ffi.Pointer<NtTypeInstance>)>>('NT_LIST');
  late final _NT_LIST = _NT_LISTPtr.asFunction<
      ffi.Pointer<NtList> Function(ffi.Pointer<NtTypeInstance>)>();

  bool NT_IS_LIST(
    ffi.Pointer<NtList> self,
  ) {
    return _NT_IS_LIST(
      self,
    );
  }

  late final _NT_IS_LISTPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtList>)>>(
          'NT_IS_LIST');
  late final _NT_IS_LIST =
      _NT_IS_LISTPtr.asFunction<bool Function(ffi.Pointer<NtList>)>();

  int nt_list_get_type() {
    return _nt_list_get_type();
  }

  late final _nt_list_get_typePtr =
      _lookup<ffi.NativeFunction<NtType Function()>>('nt_list_get_type');
  late final _nt_list_get_type =
      _nt_list_get_typePtr.asFunction<int Function()>();

  /// nt_list_alloc:
  /// @value: The value to use
  ///
  /// Allocates a new entry for a list
  ///
  /// Returns: The entry
  ffi.Pointer<NtList> nt_list_alloc(
    NtValue value,
  ) {
    return _nt_list_alloc(
      value,
    );
  }

  late final _nt_list_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtList> Function(NtValue)>>(
          'nt_list_alloc');
  late final _nt_list_alloc =
      _nt_list_allocPtr.asFunction<ffi.Pointer<NtList> Function(NtValue)>();

  /// nt_list_get_head:
  /// @self: The list
  ///
  /// Gets the head element of the list
  ///
  /// Returns: An element
  ffi.Pointer<NtList> nt_list_get_head(
    ffi.Pointer<NtList> self,
  ) {
    return _nt_list_get_head(
      self,
    );
  }

  late final _nt_list_get_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtList> Function(
              ffi.Pointer<NtList>)>>('nt_list_get_head');
  late final _nt_list_get_head = _nt_list_get_headPtr
      .asFunction<ffi.Pointer<NtList> Function(ffi.Pointer<NtList>)>();

  /// nt_list_get_tail:
  /// @self: The list
  ///
  /// Gets the tail element of the list
  ///
  /// Returns: An element
  ffi.Pointer<NtList> nt_list_get_tail(
    ffi.Pointer<NtList> self,
  ) {
    return _nt_list_get_tail(
      self,
    );
  }

  late final _nt_list_get_tailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtList> Function(
              ffi.Pointer<NtList>)>>('nt_list_get_tail');
  late final _nt_list_get_tail = _nt_list_get_tailPtr
      .asFunction<ffi.Pointer<NtList> Function(ffi.Pointer<NtList>)>();

  /// nt_list_length:
  /// @self: The list
  ///
  /// Counts the number of elements in the list starting with @self
  /// Return: THe number of elements
  int nt_list_length(
    ffi.Pointer<NtList> self,
  ) {
    return _nt_list_length(
      self,
    );
  }

  late final _nt_list_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<NtList>)>>(
          'nt_list_length');
  late final _nt_list_length =
      _nt_list_lengthPtr.asFunction<int Function(ffi.Pointer<NtList>)>();

  /// nt_list_prepend:
  /// @self: The list to use
  /// @value: The value to prepend
  ///
  /// Prepends @value into a new entry in the list.
  /// Returns: The new head of the list.
  ffi.Pointer<NtList> nt_list_prepend(
    ffi.Pointer<NtList> self,
    NtValue value,
  ) {
    return _nt_list_prepend(
      self,
      value,
    );
  }

  late final _nt_list_prependPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtList> Function(
              ffi.Pointer<NtList>, NtValue)>>('nt_list_prepend');
  late final _nt_list_prepend = _nt_list_prependPtr
      .asFunction<ffi.Pointer<NtList> Function(ffi.Pointer<NtList>, NtValue)>();

  /// nt_list_append:
  /// @self: The list to use
  /// @value: The value to append
  ///
  /// Appends @value into a new entry in the list.
  /// Returns: The new head of the list.
  ffi.Pointer<NtList> nt_list_append(
    ffi.Pointer<NtList> self,
    NtValue value,
  ) {
    return _nt_list_append(
      self,
      value,
    );
  }

  late final _nt_list_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtList> Function(
              ffi.Pointer<NtList>, NtValue)>>('nt_list_append');
  late final _nt_list_append = _nt_list_appendPtr
      .asFunction<ffi.Pointer<NtList> Function(ffi.Pointer<NtList>, NtValue)>();

  late final ffi.Pointer<ffi.Size> _NT_SIGNAL_SIZE =
      _lookup<ffi.Size>('NT_SIGNAL_SIZE');

  int get NT_SIGNAL_SIZE => _NT_SIGNAL_SIZE.value;

  set NT_SIGNAL_SIZE(int value) => _NT_SIGNAL_SIZE.value = value;

  ffi.Pointer<NtSignal> NT_SIGNAL(
    ffi.Pointer<NtTypeInstance> instance,
  ) {
    return _NT_SIGNAL(
      instance,
    );
  }

  late final _NT_SIGNALPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtSignal> Function(
              ffi.Pointer<NtTypeInstance>)>>('NT_SIGNAL');
  late final _NT_SIGNAL = _NT_SIGNALPtr.asFunction<
      ffi.Pointer<NtSignal> Function(ffi.Pointer<NtTypeInstance>)>();

  bool NT_IS_SIGNAL(
    ffi.Pointer<NtSignal> self,
  ) {
    return _NT_IS_SIGNAL(
      self,
    );
  }

  late final _NT_IS_SIGNALPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtSignal>)>>(
          'NT_IS_SIGNAL');
  late final _NT_IS_SIGNAL =
      _NT_IS_SIGNALPtr.asFunction<bool Function(ffi.Pointer<NtSignal>)>();

  int nt_signal_get_type() {
    return _nt_signal_get_type();
  }

  late final _nt_signal_get_typePtr =
      _lookup<ffi.NativeFunction<NtType Function()>>('nt_signal_get_type');
  late final _nt_signal_get_type =
      _nt_signal_get_typePtr.asFunction<int Function()>();

  /// nt_signal_new:
  ///
  /// A new non-blocking signal
  ///
  /// Returns: A new %NtSignal
  ffi.Pointer<NtSignal> nt_signal_new() {
    return _nt_signal_new();
  }

  late final _nt_signal_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtSignal> Function()>>(
          'nt_signal_new');
  late final _nt_signal_new =
      _nt_signal_newPtr.asFunction<ffi.Pointer<NtSignal> Function()>();

  /// nt_signal_new_locking:
  ///
  /// A new signal which locks every time nt_signal_emit is called
  ///
  /// Returns: A new %NtSignal
  ffi.Pointer<NtSignal> nt_signal_new_locking() {
    return _nt_signal_new_locking();
  }

  late final _nt_signal_new_lockingPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtSignal> Function()>>(
          'nt_signal_new_locking');
  late final _nt_signal_new_locking =
      _nt_signal_new_lockingPtr.asFunction<ffi.Pointer<NtSignal> Function()>();

  /// nt_signal_attach:
  /// @self: The %NtSignal
  /// @handler: The handler to add
  /// @data: The data to send to @handler
  ///
  /// Attaches a handler to the signal
  ///
  /// Returns: The ID of the signal
  int nt_signal_attach(
    ffi.Pointer<NtSignal> self,
    NtSignalHandler handler,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _nt_signal_attach(
      self,
      handler,
      data,
    );
  }

  late final _nt_signal_attachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<NtSignal>, NtSignalHandler,
              ffi.Pointer<ffi.Void>)>>('nt_signal_attach');
  late final _nt_signal_attach = _nt_signal_attachPtr.asFunction<
      int Function(
          ffi.Pointer<NtSignal>, NtSignalHandler, ffi.Pointer<ffi.Void>)>();

  /// nt_signal_detach:
  /// @self: The %NtSignal
  /// @id: The signal ID
  ///
  /// Detaches @handler from the signal
  ///
  /// Returns: The data passed in %nt_signal_attach
  ffi.Pointer<ffi.Void> nt_signal_detach(
    ffi.Pointer<NtSignal> self,
    int id,
  ) {
    return _nt_signal_detach(
      self,
      id,
    );
  }

  late final _nt_signal_detachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NtSignal>, ffi.Int)>>('nt_signal_detach');
  late final _nt_signal_detach = _nt_signal_detachPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtSignal>, int)>();

  /// nt_signal_emit:
  /// @self: The %NtSignal
  /// @arguments: The arguments to send to %NtSignalHandler
  ///
  /// Triggers signal execution
  void nt_signal_emit(
    ffi.Pointer<NtSignal> self,
    ffi.Pointer<NtTypeArgument> arguments,
  ) {
    return _nt_signal_emit(
      self,
      arguments,
    );
  }

  late final _nt_signal_emitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NtSignal>,
              ffi.Pointer<NtTypeArgument>)>>('nt_signal_emit');
  late final _nt_signal_emit = _nt_signal_emitPtr.asFunction<
      void Function(ffi.Pointer<NtSignal>, ffi.Pointer<NtTypeArgument>)>();
}

/// NtValueType:
/// @NT_VALUE_TYPE_POINTER: A pointer type
/// @NT_VALUE_TYPE_STRING: A string type
/// @NT_VALUE_TYPE_NUMBER: An integer type
/// @NT_VALUE_TYPE_BOOL: A boolean type
/// @NT_VALUE_TYPE_INSTANCE: An %NtTypeInstance type
///
/// An enum for describing what %NtValue is holding
abstract class _NtValueType {
  static const int NT_VALUE_TYPE_POINTER = 0;
  static const int NT_VALUE_TYPE_STRING = 1;
  static const int NT_VALUE_TYPE_NUMBER = 2;
  static const int NT_VALUE_TYPE_BOOL = 3;
  static const int NT_VALUE_TYPE_INSTANCE = 4;
}

/// NtTypeInstance:
/// @type: The type the instance was allocated for
/// @data_size: The total size of %NtTypeInstance
/// @ref_count: Number of references this instance has
/// @prev: The previous level instance this is tied to
///
/// Instance of a type
class _NtTypeInstance extends ffi.Struct {
  @NtType()
  external int type;

  @ffi.Size()
  external int data_size;

  @ffi.Size()
  external int ref_count;

  external ffi.Pointer<_NtTypeInstance> prev;
}

/// NtType:
///
/// ID of a registered type
typedef NtType = ffi.Uint32;

/// NtValueData:
/// @pointer: Data being held as a pointer
/// @string: Data being held as a string
/// @number: Data being held as a number
/// @boolean: Data being held as a boolean
/// @instance: Data being held as an %NtTypeInstance
///
/// A union for holding data in %NtValue
class _NtValueData extends ffi.Union {
  external ffi.Pointer<ffi.Void> pointer;

  external ffi.Pointer<ffi.Char> string;

  @ffi.Int()
  external int number;

  @ffi.Bool()
  external bool boolean;

  external ffi.Pointer<_NtTypeInstance> instance;
}

/// NtValue:
/// @type: The type of value
/// @data: The data being held
///
/// A static structure type for holding different kinds of data
class _NtValue extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external NtValueData data;
}

/// NtValueData:
/// @pointer: Data being held as a pointer
/// @string: Data being held as a string
/// @number: Data being held as a number
/// @boolean: Data being held as a boolean
/// @instance: Data being held as an %NtTypeInstance
///
/// A union for holding data in %NtValue
typedef NtValueData = _NtValueData;

/// NtTypeArgument:
/// @name: Argument name
/// @value: Argument value
///
/// A structure which holds a single argument for %NtTypeInstance and %NtSignal.
class _NtTypeArgument extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external NtValue value;
}

/// NtValue:
/// @type: The type of value
/// @data: The data being held
///
/// A static structure type for holding different kinds of data
typedef NtValue = _NtValue;

/// NtTypeArgument:
/// @name: Argument name
/// @value: Argument value
///
/// A structure which holds a single argument for %NtTypeInstance and %NtSignal.
typedef NtTypeArgument = _NtTypeArgument;

/// NtTypeFlags:
/// @NT_TYPE_FLAG_STATIC: Defines a static type, this means it cannot be derived.
/// @NT_TYPE_FLAG_DYNAMIC: Defines a dynamic type, this means the it can be derived.
/// @NT_TYPE_FLAG_NOREF: Defines a type which cannot be referenced
///
/// Enum of flags for registering types
abstract class _NtTypeFlags {
  static const int NT_TYPE_FLAG_STATIC = 1;
  static const int NT_TYPE_FLAG_DYNAMIC = 0;
  static const int NT_TYPE_FLAG_NOREF = 2;
}

/// NtTypeInfo:
/// @id: The ID of the type
/// @flags: Flags describing how the type can work
/// @extends: An array which ends with "NT_TYPE_NONE" to determine all parent types
/// @size: Size of the allocated data
/// @construct: Method to run when this type is allocated by %nt_type_instance_new
/// @destroy: Method to run when this type is deallocated by %nt_type_instance_unref
///
/// Describes how a type should be defined
class _NtTypeInfo extends ffi.Struct {
  @NtType()
  external int id;

  @ffi.Int32()
  external int flags;

  external ffi.Pointer<NtType> extends1;

  @ffi.Size()
  external int size;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<_NtTypeInstance>, ffi.Pointer<NtTypeArgument>)>>
      construct;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<_NtTypeInstance>)>>
      destroy;

  external ffi.Pointer<ffi.Char> sname;
}

/// NtTypeInfo:
/// @id: The ID of the type
/// @flags: Flags describing how the type can work
/// @extends: An array which ends with "NT_TYPE_NONE" to determine all parent types
/// @size: Size of the allocated data
/// @construct: Method to run when this type is allocated by %nt_type_instance_new
/// @destroy: Method to run when this type is deallocated by %nt_type_instance_unref
///
/// Describes how a type should be defined
typedef NtTypeInfo = _NtTypeInfo;

/// NtTypeInstance:
/// @type: The type the instance was allocated for
/// @data_size: The total size of %NtTypeInstance
/// @ref_count: Number of references this instance has
/// @prev: The previous level instance this is tied to
///
/// Instance of a type
typedef NtTypeInstance = _NtTypeInstance;

/// NtBacktraceEntry:
/// @prev: The entry which was called from this
/// @file: The source file
/// @method: The method name
/// @line: The line in the source file
/// @address: The address of the method
///
/// An entry in the backtrace
class _NtBacktraceEntry extends ffi.Struct {
  external ffi.Pointer<_NtBacktraceEntry> prev;

  external ffi.Pointer<ffi.Char> file;

  external ffi.Pointer<ffi.Char> method;

  @ffi.Int()
  external int line;

  external ffi.Pointer<ffi.Void> address;
}

/// NtBacktrace:
/// @entries: Linked list of entries
///
/// Backtrace
class _NtBacktrace extends ffi.Struct {
  external NtTypeInstance instance;

  external ffi.Pointer<_NtBacktraceEntry> entries;
}

/// NtBacktrace:
/// @entries: Linked list of entries
///
/// Backtrace
typedef NtBacktrace = _NtBacktrace;

/// NtError:
/// @instance: The %NtTypeInstance associated
/// @priv: Private data
///
/// An error
class _NtError extends ffi.Struct {
  external NtTypeInstance instance;

  /// < private >
  external ffi.Pointer<_NtErrorPrivate> priv;
}

class _NtErrorPrivate extends ffi.Opaque {}

/// NtError:
/// @instance: The %NtTypeInstance associated
/// @priv: Private data
///
/// An error
typedef NtError = _NtError;

/// NtList:
/// @instance: The %NtTypeInstance associated
/// @prev: The previous element
/// @next: The next element
/// @value: The value being held in the list element
///
/// A linked-list type which holds %NtValue
class _NtList extends ffi.Struct {
  external NtTypeInstance instance;

  external ffi.Pointer<_NtList> prev;

  external ffi.Pointer<_NtList> next;

  external NtValue value;
}

/// NtList:
/// @instance: The %NtTypeInstance associated
/// @prev: The previous element
/// @next: The next element
/// @value: The value being held in the list element
///
/// A linked-list type which holds %NtValue
typedef NtList = _NtList;

/// NtSignal:
/// @instance: The %NtTypeInstance associated
/// @priv: Private data
///
/// A signal
class _NtSignal extends ffi.Struct {
  external NtTypeInstance instance;

  /// < private >
  external ffi.Pointer<_NtSignalPrivate> priv;
}

class _NtSignalPrivate extends ffi.Opaque {}

/// NtSignal:
/// @instance: The %NtTypeInstance associated
/// @priv: Private data
///
/// A signal
typedef NtSignal = _NtSignal;

/// NtSignalHandler:
/// @signal: The signal which was emitted
/// @arguments: The arguments passed to the emit method
/// @data: User data
///
/// Method type used for signal emittion.
///
/// Returns: %TRUE to continue, %FALSE to stop
typedef NtSignalHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<NtSignal>, ffi.Pointer<NtTypeArgument>,
            ffi.Pointer<ffi.Void>)>>;

const int NT_TYPE_NONE = 0;
