// ingore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_name

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:neutron_elemental/bindings.dart' as _imp1;
import 'package:flutter_engine/bindings.dart' as _imp2;

/// Bindings for Neutron's Graphics API
///
class NeutronGraphics {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NeutronGraphics(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NeutronGraphics.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Size> _NT_SHADER_SIZE =
      _lookup<ffi.Size>('NT_SHADER_SIZE');

  int get NT_SHADER_SIZE => _NT_SHADER_SIZE.value;

  set NT_SHADER_SIZE(int value) => _NT_SHADER_SIZE.value = value;

  ffi.Pointer<NtShader> NT_SHADER(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_SHADER(
      instance,
    );
  }

  late final _NT_SHADERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtShader> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_SHADER');
  late final _NT_SHADER = _NT_SHADERPtr.asFunction<
      ffi.Pointer<NtShader> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_SHADER(
    ffi.Pointer<NtShader> self,
  ) {
    return _NT_IS_SHADER(
      self,
    );
  }

  late final _NT_IS_SHADERPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtShader>)>>(
          'NT_IS_SHADER');
  late final _NT_IS_SHADER =
      _NT_IS_SHADERPtr.asFunction<bool Function(ffi.Pointer<NtShader>)>();

  _imp1.NtType nt_shader_get_type() {
    return _nt_shader_get_type();
  }

  late final _nt_shader_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_shader_get_type');
  late final _nt_shader_get_type =
      _nt_shader_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_shader_get_kind:
  /// @self: The instance of the shader
  ///
  /// Used for getting the kind of shader this is.
  ///
  /// Returns: The kind of shader
  int nt_shader_get_kind(
    ffi.Pointer<NtShader> self,
  ) {
    return _nt_shader_get_kind(
      self,
    );
  }

  late final _nt_shader_get_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<NtShader>)>>(
          'nt_shader_get_kind');
  late final _nt_shader_get_kind =
      _nt_shader_get_kindPtr.asFunction<int Function(ffi.Pointer<NtShader>)>();

  /// nt_shader_get_source:
  /// @self: The instance of the shader
  /// @len: Pointer for storing the length
  ///
  /// Used for getting the source code of the shader.
  ///
  /// Returns: An allocated string of the shader source code.
  ffi.Pointer<ffi.Char> nt_shader_get_source(
    ffi.Pointer<NtShader> self,
    ffi.Pointer<ffi.Size> len,
  ) {
    return _nt_shader_get_source(
      self,
      len,
    );
  }

  late final _nt_shader_get_sourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<NtShader>,
              ffi.Pointer<ffi.Size>)>>('nt_shader_get_source');
  late final _nt_shader_get_source = _nt_shader_get_sourcePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<NtShader>, ffi.Pointer<ffi.Size>)>();

  /// nt_shader_get_binary:
  /// @self: The instance of the shader
  /// @len: Pointer for storing the length
  ///
  /// Used for getting the binary code of the shader.
  ///
  /// Returns: An pointer of the binary
  ffi.Pointer<ffi.Void> nt_shader_get_binary(
    ffi.Pointer<NtShader> self,
    ffi.Pointer<ffi.Size> len,
  ) {
    return _nt_shader_get_binary(
      self,
      len,
    );
  }

  late final _nt_shader_get_binaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtShader>,
              ffi.Pointer<ffi.Size>)>>('nt_shader_get_binary');
  late final _nt_shader_get_binary = _nt_shader_get_binaryPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<NtShader>, ffi.Pointer<ffi.Size>)>();

  late final ffi.Pointer<ffi.Size> _NT_SCENE_SIZE =
      _lookup<ffi.Size>('NT_SCENE_SIZE');

  int get NT_SCENE_SIZE => _NT_SCENE_SIZE.value;

  set NT_SCENE_SIZE(int value) => _NT_SCENE_SIZE.value = value;

  ffi.Pointer<NtScene> NT_SCENE(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_SCENE(
      instance,
    );
  }

  late final _NT_SCENEPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtScene> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_SCENE');
  late final _NT_SCENE = _NT_SCENEPtr.asFunction<
      ffi.Pointer<NtScene> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_SCENE(
    ffi.Pointer<NtScene> self,
  ) {
    return _NT_IS_SCENE(
      self,
    );
  }

  late final _NT_IS_SCENEPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtScene>)>>(
          'NT_IS_SCENE');
  late final _NT_IS_SCENE =
      _NT_IS_SCENEPtr.asFunction<bool Function(ffi.Pointer<NtScene>)>();

  _imp1.NtType nt_scene_get_type() {
    return _nt_scene_get_type();
  }

  late final _nt_scene_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>('nt_scene_get_type');
  late final _nt_scene_get_type =
      _nt_scene_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_scene_new:
  ///
  /// Creates a new scene.
  /// Returns: A new scene.
  ffi.Pointer<NtScene> nt_scene_new() {
    return _nt_scene_new();
  }

  late final _nt_scene_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtScene> Function()>>(
          'nt_scene_new');
  late final _nt_scene_new =
      _nt_scene_newPtr.asFunction<ffi.Pointer<NtScene> Function()>();

  /// nt_scene_add_layer:
  /// @self: The scene
  /// @renderer: The layer
  ///
  /// Adds the layer into the scene. This does not reference the layer.
  void nt_scene_add_layer(
    ffi.Pointer<NtScene> self,
    ffi.Pointer<_NtSceneLayer> layer,
  ) {
    return _nt_scene_add_layer(
      self,
      layer,
    );
  }

  late final _nt_scene_add_layerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NtScene>,
              ffi.Pointer<_NtSceneLayer>)>>('nt_scene_add_layer');
  late final _nt_scene_add_layer = _nt_scene_add_layerPtr.asFunction<
      void Function(ffi.Pointer<NtScene>, ffi.Pointer<_NtSceneLayer>)>();

  /// nt_scene_render:
  /// @self: The scene
  /// @renderer: The renderer
  ///
  /// Renders the scene (@self) onto the renderer (@renderer).
  void nt_scene_render(
    ffi.Pointer<NtScene> self,
    ffi.Pointer<_NtRenderer> renderer,
  ) {
    return _nt_scene_render(
      self,
      renderer,
    );
  }

  late final _nt_scene_renderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NtScene>,
              ffi.Pointer<_NtRenderer>)>>('nt_scene_render');
  late final _nt_scene_render = _nt_scene_renderPtr.asFunction<
      void Function(ffi.Pointer<NtScene>, ffi.Pointer<_NtRenderer>)>();

  /// nt_scene_clean:
  /// @self: The scene
  ///
  /// Cleans the scene's layers
  void nt_scene_clean(
    ffi.Pointer<NtScene> self,
  ) {
    return _nt_scene_clean(
      self,
    );
  }

  late final _nt_scene_cleanPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtScene>)>>(
          'nt_scene_clean');
  late final _nt_scene_clean =
      _nt_scene_cleanPtr.asFunction<void Function(ffi.Pointer<NtScene>)>();

  late final ffi.Pointer<ffi.Size> _NT_SCENE_LAYER_SIZE =
      _lookup<ffi.Size>('NT_SCENE_LAYER_SIZE');

  int get NT_SCENE_LAYER_SIZE => _NT_SCENE_LAYER_SIZE.value;

  set NT_SCENE_LAYER_SIZE(int value) => _NT_SCENE_LAYER_SIZE.value = value;

  ffi.Pointer<NtSceneLayer> NT_SCENE_LAYER(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_SCENE_LAYER(
      instance,
    );
  }

  late final _NT_SCENE_LAYERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtSceneLayer> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_SCENE_LAYER');
  late final _NT_SCENE_LAYER = _NT_SCENE_LAYERPtr.asFunction<
      ffi.Pointer<NtSceneLayer> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_SCENE_LAYER(
    ffi.Pointer<NtSceneLayer> self,
  ) {
    return _NT_IS_SCENE_LAYER(
      self,
    );
  }

  late final _NT_IS_SCENE_LAYERPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtSceneLayer>)>>(
          'NT_IS_SCENE_LAYER');
  late final _NT_IS_SCENE_LAYER = _NT_IS_SCENE_LAYERPtr.asFunction<
      bool Function(ffi.Pointer<NtSceneLayer>)>();

  _imp1.NtType nt_scene_layer_get_type() {
    return _nt_scene_layer_get_type();
  }

  late final _nt_scene_layer_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_scene_layer_get_type');
  late final _nt_scene_layer_get_type =
      _nt_scene_layer_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_scene_layer_render:
  /// @self: The scene layer
  /// @renderer: The renderer
  ///
  /// Renders the scene layer (@self) onto the renderer (@renderer)
  void nt_scene_layer_render(
    ffi.Pointer<NtSceneLayer> self,
    ffi.Pointer<_NtRenderer> renderer,
  ) {
    return _nt_scene_layer_render(
      self,
      renderer,
    );
  }

  late final _nt_scene_layer_renderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NtSceneLayer>,
              ffi.Pointer<_NtRenderer>)>>('nt_scene_layer_render');
  late final _nt_scene_layer_render = _nt_scene_layer_renderPtr.asFunction<
      void Function(ffi.Pointer<NtSceneLayer>, ffi.Pointer<_NtRenderer>)>();

  /// nt_scene_layer_clean:
  /// @self: The scene layer
  ///
  /// Cleans the scene layers
  void nt_scene_layer_clean(
    ffi.Pointer<NtSceneLayer> self,
  ) {
    return _nt_scene_layer_clean(
      self,
    );
  }

  late final _nt_scene_layer_cleanPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtSceneLayer>)>>(
          'nt_scene_layer_clean');
  late final _nt_scene_layer_clean = _nt_scene_layer_cleanPtr
      .asFunction<void Function(ffi.Pointer<NtSceneLayer>)>();

  late final ffi.Pointer<ffi.Size> _NT_SHADER_PROGRAM_SIZE =
      _lookup<ffi.Size>('NT_SHADER_PROGRAM_SIZE');

  int get NT_SHADER_PROGRAM_SIZE => _NT_SHADER_PROGRAM_SIZE.value;

  set NT_SHADER_PROGRAM_SIZE(int value) =>
      _NT_SHADER_PROGRAM_SIZE.value = value;

  ffi.Pointer<NtShaderProgram> NT_SHADER_PROGRAM(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_SHADER_PROGRAM(
      instance,
    );
  }

  late final _NT_SHADER_PROGRAMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtShaderProgram> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_SHADER_PROGRAM');
  late final _NT_SHADER_PROGRAM = _NT_SHADER_PROGRAMPtr.asFunction<
      ffi.Pointer<NtShaderProgram> Function(
          ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_SHADER_PROGRAM(
    ffi.Pointer<NtShaderProgram> self,
  ) {
    return _NT_IS_SHADER_PROGRAM(
      self,
    );
  }

  late final _NT_IS_SHADER_PROGRAMPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtShaderProgram>)>>(
      'NT_IS_SHADER_PROGRAM');
  late final _NT_IS_SHADER_PROGRAM = _NT_IS_SHADER_PROGRAMPtr.asFunction<
      bool Function(ffi.Pointer<NtShaderProgram>)>();

  _imp1.NtType nt_shader_program_get_type() {
    return _nt_shader_program_get_type();
  }

  late final _nt_shader_program_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_shader_program_get_type');
  late final _nt_shader_program_get_type =
      _nt_shader_program_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_shader_program_attach:
  /// @self: Instance of a shader program
  /// @shader: The shader to attach
  ///
  /// Attaches the shader to the program.
  ///
  /// Returns: %TRUE if the shader was added, %FALSE if it failed.
  bool nt_shader_program_attach(
    ffi.Pointer<NtShaderProgram> self,
    ffi.Pointer<NtShader> shader,
  ) {
    return _nt_shader_program_attach(
      self,
      shader,
    );
  }

  late final _nt_shader_program_attachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<NtShaderProgram>,
              ffi.Pointer<NtShader>)>>('nt_shader_program_attach');
  late final _nt_shader_program_attach =
      _nt_shader_program_attachPtr.asFunction<
          bool Function(ffi.Pointer<NtShaderProgram>, ffi.Pointer<NtShader>)>();

  /// nt_shader_program_detach:
  /// @self: Instance of a shader program
  /// @shader: The shader to detach
  ///
  /// Detaches the shader to the program.
  ///
  /// Returns: %TRUE if the shader was removed, %FALSE if it failed.
  bool nt_shader_program_detach(
    ffi.Pointer<NtShaderProgram> self,
    ffi.Pointer<NtShader> shader,
  ) {
    return _nt_shader_program_detach(
      self,
      shader,
    );
  }

  late final _nt_shader_program_detachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<NtShaderProgram>,
              ffi.Pointer<NtShader>)>>('nt_shader_program_detach');
  late final _nt_shader_program_detach =
      _nt_shader_program_detachPtr.asFunction<
          bool Function(ffi.Pointer<NtShaderProgram>, ffi.Pointer<NtShader>)>();

  /// nt_shader_program_link:
  /// @self: Instance of a shader program
  ///
  /// Links all the shaders together which makes the program usable.
  ///
  /// Returns: %TRUE if the shader program was linked, %FALSE if it failed.
  bool nt_shader_program_link(
    ffi.Pointer<NtShaderProgram> self,
  ) {
    return _nt_shader_program_link(
      self,
    );
  }

  late final _nt_shader_program_linkPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtShaderProgram>)>>(
      'nt_shader_program_link');
  late final _nt_shader_program_link = _nt_shader_program_linkPtr
      .asFunction<bool Function(ffi.Pointer<NtShaderProgram>)>();

  /// nt_shader_program_get_binary:
  /// @self: Instance of a shader program
  /// @len: Pointer for storing the length
  ///
  /// Used for getting the binary code of the shader program.
  ///
  /// Returns: An pointer of the binary
  ffi.Pointer<ffi.Void> nt_shader_program_get_binary(
    ffi.Pointer<NtShaderProgram> self,
    ffi.Pointer<ffi.Size> len,
  ) {
    return _nt_shader_program_get_binary(
      self,
      len,
    );
  }

  late final _nt_shader_program_get_binaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtShaderProgram>,
              ffi.Pointer<ffi.Size>)>>('nt_shader_program_get_binary');
  late final _nt_shader_program_get_binary =
      _nt_shader_program_get_binaryPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NtShaderProgram>, ffi.Pointer<ffi.Size>)>();

  late final ffi.Pointer<ffi.Size> _NT_RENDERER_SIZE =
      _lookup<ffi.Size>('NT_RENDERER_SIZE');

  int get NT_RENDERER_SIZE => _NT_RENDERER_SIZE.value;

  set NT_RENDERER_SIZE(int value) => _NT_RENDERER_SIZE.value = value;

  ffi.Pointer<NtRenderer> NT_RENDERER(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_RENDERER(
      instance,
    );
  }

  late final _NT_RENDERERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtRenderer> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_RENDERER');
  late final _NT_RENDERER = _NT_RENDERERPtr.asFunction<
      ffi.Pointer<NtRenderer> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_RENDERER(
    ffi.Pointer<NtRenderer> self,
  ) {
    return _NT_IS_RENDERER(
      self,
    );
  }

  late final _NT_IS_RENDERERPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtRenderer>)>>(
          'NT_IS_RENDERER');
  late final _NT_IS_RENDERER =
      _NT_IS_RENDERERPtr.asFunction<bool Function(ffi.Pointer<NtRenderer>)>();

  _imp1.NtType nt_renderer_get_type() {
    return _nt_renderer_get_type();
  }

  late final _nt_renderer_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_renderer_get_type');
  late final _nt_renderer_get_type =
      _nt_renderer_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_renderer_is_software:
  /// @self: The %NtRenderer instance
  ///
  /// Gets whether or not the renderer is using software or hardware rendering.
  /// Returns: %true if the renderer is software rendering, %false if the renderer is hardware rendering
  bool nt_renderer_is_software(
    ffi.Pointer<NtRenderer> self,
  ) {
    return _nt_renderer_is_software(
      self,
    );
  }

  late final _nt_renderer_is_softwarePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtRenderer>)>>(
          'nt_renderer_is_software');
  late final _nt_renderer_is_software = _nt_renderer_is_softwarePtr
      .asFunction<bool Function(ffi.Pointer<NtRenderer>)>();

  /// nt_renderer_get_config:
  /// @self: The %NtRenderer instance
  ///
  /// Gets the renderer configuration for Flutter
  /// Returns: A pointer to the renderer configuration
  ffi.Pointer<FlutterRendererConfig> nt_renderer_get_config(
    ffi.Pointer<NtRenderer> self,
  ) {
    return _nt_renderer_get_config(
      self,
    );
  }

  late final _nt_renderer_get_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FlutterRendererConfig> Function(
              ffi.Pointer<NtRenderer>)>>('nt_renderer_get_config');
  late final _nt_renderer_get_config = _nt_renderer_get_configPtr.asFunction<
      ffi.Pointer<FlutterRendererConfig> Function(ffi.Pointer<NtRenderer>)>();

  /// nt_renderer_get_compositor:
  /// @self: The %NtRenderer instance
  ///
  /// Gets the compositor for Flutter
  /// Returns: A pointer to the compositor
  ffi.Pointer<FlutterCompositor> nt_renderer_get_compositor(
    ffi.Pointer<NtRenderer> self,
  ) {
    return _nt_renderer_get_compositor(
      self,
    );
  }

  late final _nt_renderer_get_compositorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FlutterCompositor> Function(
              ffi.Pointer<NtRenderer>)>>('nt_renderer_get_compositor');
  late final _nt_renderer_get_compositor =
      _nt_renderer_get_compositorPtr.asFunction<
          ffi.Pointer<FlutterCompositor> Function(ffi.Pointer<NtRenderer>)>();

  /// nt_renderer_wait_sync:
  /// @self: The %NtRenderer instance
  ///
  /// Causes the renderer to wait for any synchronization action.
  /// Use this before calling %nt_renderer_render.
  void nt_renderer_wait_sync(
    ffi.Pointer<NtRenderer> self,
  ) {
    return _nt_renderer_wait_sync(
      self,
    );
  }

  late final _nt_renderer_wait_syncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtRenderer>)>>(
          'nt_renderer_wait_sync');
  late final _nt_renderer_wait_sync = _nt_renderer_wait_syncPtr
      .asFunction<void Function(ffi.Pointer<NtRenderer>)>();

  /// nt_renderer_render:
  /// @self: The %NtRenderer instance
  ///
  /// Causes the renderer to actually render.
  /// This does not use %nt_renderer_wait_sync so be sure to call it first.
  void nt_renderer_render(
    ffi.Pointer<NtRenderer> self,
  ) {
    return _nt_renderer_render(
      self,
    );
  }

  late final _nt_renderer_renderPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NtRenderer>)>>(
          'nt_renderer_render');
  late final _nt_renderer_render = _nt_renderer_renderPtr
      .asFunction<void Function(ffi.Pointer<NtRenderer>)>();
}

/// NtShaderKind:
/// @NT_SHADER_VERT: Vertex shader
/// @NT_SHADER_TESS: Tessellation shader
/// @NT_SHADER_GEOM: Geometry shader
/// @NT_SHADER_FRAG: Fragment shader
/// @NT_SHADER_COMP: Compute shader
///
/// The different kinds of shader
abstract class _NtShaderKind {
  static const int NT_SHADER_VERT = 0;
  static const int NT_SHADER_TESS = 1;
  static const int NT_SHADER_GEOM = 2;
  static const int NT_SHADER_FRAG = 3;
  static const int NT_SHADER_COMP = 4;
}

/// NtShader:
/// @instance: The %NtTypeInstance associated with this
/// @get_kind: Method for getting the kind of shader
/// @get_source: Method for getting the shader code
/// @get_binary: Method for getting the binary code
///
/// A shader
class _NtShader extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<_NtShader>)>> get_kind;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<_NtShader>, ffi.Pointer<ffi.Size>)>> get_source;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<_NtShader>, ffi.Pointer<ffi.Size>)>> get_binary;
}

/// NtShader:
/// @instance: The %NtTypeInstance associated with this
/// @get_kind: Method for getting the kind of shader
/// @get_source: Method for getting the shader code
/// @get_binary: Method for getting the binary code
///
/// A shader
typedef NtShader = _NtShader;

/// NtRenderer:
/// @instance: The %NtTypeInstance associated with this
/// @is_software: Method for getting whether or not the renderer is doing software rendering
/// @get_config: Method for getting the renderer configuration for Flutter
/// @get_compositor: Method for getting the compositor for Flutter
/// @wait_sync: Method for causing the renderer to wait for synchronization
/// @render: Method for causing the renderer to perform the rendering action
/// @pre_render: Signal triggered before rendering begins
/// @post_render: Signal triggered once rendering is done
///
/// Base type for a renderer
class _NtRenderer extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<_NtRenderer>)>>
      is_software;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<FlutterRendererConfig> Function(
              ffi.Pointer<_NtRenderer>)>> get_config;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<FlutterCompositor> Function(
              ffi.Pointer<_NtRenderer>)>> get_compositor;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<_NtRenderer>)>>
      wait_sync;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<_NtRenderer>)>> render;

  external ffi.Pointer<_imp1.NtSignal> pre_render;

  external ffi.Pointer<_imp1.NtSignal> post_render;

  /// < private >
  external ffi.Pointer<_NtRendererPrivate> priv;
}

typedef FlutterRendererConfig = _imp2.FlutterRendererConfig;
typedef FlutterCompositor = _imp2.FlutterCompositor;

class _NtRendererPrivate extends ffi.Opaque {}

/// NtSceneLayer:
/// @instance: The %NtTypeInstance associated with this
/// @render: Method for rendering
/// @clean: Method for cleaning
/// @priv: Private data
///
/// A layer in a scene for rendering
class _NtSceneLayer extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<_NtSceneLayer>, ffi.Pointer<_NtRenderer>)>> render;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<_NtSceneLayer>)>> clean;

  /// < private >
  external ffi.Pointer<_NtSceneLayerPrivate> priv;
}

class _NtSceneLayerPrivate extends ffi.Opaque {}

/// NtScene:
/// @instance: The %NtTypeInstance associated with this
/// @priv: Private data
///
/// Scene for rendering layers
class _NtScene extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  /// < private >
  external ffi.Pointer<_NtScenePrivate> priv;
}

class _NtScenePrivate extends ffi.Opaque {}

/// NtScene:
/// @instance: The %NtTypeInstance associated with this
/// @priv: Private data
///
/// Scene for rendering layers
typedef NtScene = _NtScene;

/// NtSceneLayer:
/// @instance: The %NtTypeInstance associated with this
/// @render: Method for rendering
/// @clean: Method for cleaning
/// @priv: Private data
///
/// A layer in a scene for rendering
typedef NtSceneLayer = _NtSceneLayer;

/// NtShaderProgram:
/// @instance: The %NtTypeInstance associated with this
/// @attach: Method for attaching a shader to the program
/// @detach: Method for detaching a shader from the program
/// @link: Method for linking the shaders
/// @get_binary: Method for getting the binary data of the shader
///
/// A shader program
class _NtShaderProgram extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<_NtShaderProgram>, ffi.Pointer<NtShader>)>> attach;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<_NtShaderProgram>, ffi.Pointer<NtShader>)>> detach;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<_NtShaderProgram>)>>
      link;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<_NtShaderProgram>, ffi.Pointer<ffi.Size>)>>
      get_binary;
}

/// NtShaderProgram:
/// @instance: The %NtTypeInstance associated with this
/// @attach: Method for attaching a shader to the program
/// @detach: Method for detaching a shader from the program
/// @link: Method for linking the shaders
/// @get_binary: Method for getting the binary data of the shader
///
/// A shader program
typedef NtShaderProgram = _NtShaderProgram;

/// NtRenderer:
/// @instance: The %NtTypeInstance associated with this
/// @is_software: Method for getting whether or not the renderer is doing software rendering
/// @get_config: Method for getting the renderer configuration for Flutter
/// @get_compositor: Method for getting the compositor for Flutter
/// @wait_sync: Method for causing the renderer to wait for synchronization
/// @render: Method for causing the renderer to perform the rendering action
/// @pre_render: Signal triggered before rendering begins
/// @post_render: Signal triggered once rendering is done
///
/// Base type for a renderer
typedef NtRenderer = _NtRenderer;
