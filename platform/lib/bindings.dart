// ingore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_name

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:neutron_elemental/bindings.dart' as _imp1;

/// Bindings for Neutron's Platform
///
class NeutronPlatform {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NeutronPlatform(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NeutronPlatform.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Size> _NT_DEVICE_ENUM_SIZE =
      _lookup<ffi.Size>('NT_DEVICE_ENUM_SIZE');

  int get NT_DEVICE_ENUM_SIZE => _NT_DEVICE_ENUM_SIZE.value;

  set NT_DEVICE_ENUM_SIZE(int value) => _NT_DEVICE_ENUM_SIZE.value = value;

  ffi.Pointer<NtDeviceEnum> NT_DEVICE_ENUM(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_DEVICE_ENUM(
      instance,
    );
  }

  late final _NT_DEVICE_ENUMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtDeviceEnum> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_DEVICE_ENUM');
  late final _NT_DEVICE_ENUM = _NT_DEVICE_ENUMPtr.asFunction<
      ffi.Pointer<NtDeviceEnum> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_DEVICE_ENUM(
    ffi.Pointer<NtDeviceEnum> self,
  ) {
    return _NT_IS_DEVICE_ENUM(
      self,
    );
  }

  late final _NT_IS_DEVICE_ENUMPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtDeviceEnum>)>>(
          'NT_IS_DEVICE_ENUM');
  late final _NT_IS_DEVICE_ENUM = _NT_IS_DEVICE_ENUMPtr.asFunction<
      bool Function(ffi.Pointer<NtDeviceEnum>)>();

  _imp1.NtType nt_device_enum_get_type() {
    return _nt_device_enum_get_type();
  }

  late final _nt_device_enum_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_device_enum_get_type');
  late final _nt_device_enum_get_type =
      _nt_device_enum_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_device_enum_count:
  /// @self: The %NtDeviceEnum instance
  /// @query: The query to use
  ///
  /// Queries all devices and returns the number of devices discovered for a given query
  ///
  /// Returns: The number of devices
  int nt_device_enum_count(
    ffi.Pointer<NtDeviceEnum> self,
    NtDeviceQuery query,
  ) {
    return _nt_device_enum_count(
      self,
      query,
    );
  }

  late final _nt_device_enum_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<NtDeviceEnum>,
              NtDeviceQuery)>>('nt_device_enum_count');
  late final _nt_device_enum_count = _nt_device_enum_countPtr
      .asFunction<int Function(ffi.Pointer<NtDeviceEnum>, NtDeviceQuery)>();

  /// nt_device_enum_query:
  /// @self: The %NtDeviceEnum instance
  /// @query: The query to use
  ///
  /// Queries all devices
  ///
  /// Returns: An %NtList holding %NtDevice
  ffi.Pointer<_imp1.NtList> nt_device_enum_query(
    ffi.Pointer<NtDeviceEnum> self,
    NtDeviceQuery query,
  ) {
    return _nt_device_enum_query(
      self,
      query,
    );
  }

  late final _nt_device_enum_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_imp1.NtList> Function(ffi.Pointer<NtDeviceEnum>,
              NtDeviceQuery)>>('nt_device_enum_query');
  late final _nt_device_enum_query = _nt_device_enum_queryPtr.asFunction<
      ffi.Pointer<_imp1.NtList> Function(
          ffi.Pointer<NtDeviceEnum>, NtDeviceQuery)>();

  late final ffi.Pointer<ffi.Size> _NT_PLATFORM_SIZE =
      _lookup<ffi.Size>('NT_PLATFORM_SIZE');

  int get NT_PLATFORM_SIZE => _NT_PLATFORM_SIZE.value;

  set NT_PLATFORM_SIZE(int value) => _NT_PLATFORM_SIZE.value = value;

  ffi.Pointer<NtPlatform> NT_PLATFORM(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_PLATFORM(
      instance,
    );
  }

  late final _NT_PLATFORMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtPlatform> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_PLATFORM');
  late final _NT_PLATFORM = _NT_PLATFORMPtr.asFunction<
      ffi.Pointer<NtPlatform> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_PLATFORM(
    ffi.Pointer<NtPlatform> self,
  ) {
    return _NT_IS_PLATFORM(
      self,
    );
  }

  late final _NT_IS_PLATFORMPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtPlatform>)>>(
          'NT_IS_PLATFORM');
  late final _NT_IS_PLATFORM =
      _NT_IS_PLATFORMPtr.asFunction<bool Function(ffi.Pointer<NtPlatform>)>();

  _imp1.NtType nt_platform_get_type() {
    return _nt_platform_get_type();
  }

  late final _nt_platform_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_platform_get_type');
  late final _nt_platform_get_type =
      _nt_platform_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_platform_get_global:
  ///
  /// Gets the global platform instance
  ///
  /// Returns: An instance of %NtPlatform
  ffi.Pointer<NtPlatform> nt_platform_get_global() {
    return _nt_platform_get_global();
  }

  late final _nt_platform_get_globalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtPlatform> Function()>>(
          'nt_platform_get_global');
  late final _nt_platform_get_global = _nt_platform_get_globalPtr
      .asFunction<ffi.Pointer<NtPlatform> Function()>();

  /// nt_platform_get_os:
  /// @self: The %NtPlatform instance to use
  ///
  /// Get the operating system the platform is running on
  /// Returns: The operating system the platform is running on
  int nt_platform_get_os(
    ffi.Pointer<NtPlatform> self,
  ) {
    return _nt_platform_get_os(
      self,
    );
  }

  late final _nt_platform_get_osPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<NtPlatform>)>>(
          'nt_platform_get_os');
  late final _nt_platform_get_os = _nt_platform_get_osPtr
      .asFunction<int Function(ffi.Pointer<NtPlatform>)>();

  /// nt_platform_get_arch:
  /// @self: The %NtPlatform instance to use
  ///
  /// Get the CPU architecture the platform is running on
  /// Returns: The CPU architecture the platform is running on
  int nt_platform_get_arch(
    ffi.Pointer<NtPlatform> self,
  ) {
    return _nt_platform_get_arch(
      self,
    );
  }

  late final _nt_platform_get_archPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<NtPlatform>)>>(
          'nt_platform_get_arch');
  late final _nt_platform_get_arch = _nt_platform_get_archPtr
      .asFunction<int Function(ffi.Pointer<NtPlatform>)>();

  /// nt_platform_get_device_enum:
  /// @self: The %NtPlatform instance to use
  ///
  /// Gets the device enumerator
  /// Returns: The device enumerator for the platform
  ffi.Pointer<NtDeviceEnum> nt_platform_get_device_enum(
    ffi.Pointer<NtPlatform> self,
  ) {
    return _nt_platform_get_device_enum(
      self,
    );
  }

  late final _nt_platform_get_device_enumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtDeviceEnum> Function(
              ffi.Pointer<NtPlatform>)>>('nt_platform_get_device_enum');
  late final _nt_platform_get_device_enum =
      _nt_platform_get_device_enumPtr.asFunction<
          ffi.Pointer<NtDeviceEnum> Function(ffi.Pointer<NtPlatform>)>();

  /// nt_platform_get_current_process:
  /// @self: The %NtPlatform instance to use
  ///
  /// Gets the currently running process
  ///
  /// Returns: Instance of the currently running %NtProcess
  ffi.Pointer<_NtProcess> nt_platform_get_current_process(
    ffi.Pointer<NtPlatform> self,
  ) {
    return _nt_platform_get_current_process(
      self,
    );
  }

  late final _nt_platform_get_current_processPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_NtProcess> Function(
              ffi.Pointer<NtPlatform>)>>('nt_platform_get_current_process');
  late final _nt_platform_get_current_process =
      _nt_platform_get_current_processPtr.asFunction<
          ffi.Pointer<_NtProcess> Function(ffi.Pointer<NtPlatform>)>();

  late final ffi.Pointer<ffi.Size> _NT_THREAD_SIZE =
      _lookup<ffi.Size>('NT_THREAD_SIZE');

  int get NT_THREAD_SIZE => _NT_THREAD_SIZE.value;

  set NT_THREAD_SIZE(int value) => _NT_THREAD_SIZE.value = value;

  ffi.Pointer<NtThread> NT_THREAD(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_THREAD(
      instance,
    );
  }

  late final _NT_THREADPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtThread> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_THREAD');
  late final _NT_THREAD = _NT_THREADPtr.asFunction<
      ffi.Pointer<NtThread> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_THREAD(
    ffi.Pointer<NtThread> self,
  ) {
    return _NT_IS_THREAD(
      self,
    );
  }

  late final _NT_IS_THREADPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtThread>)>>(
          'NT_IS_THREAD');
  late final _NT_IS_THREAD =
      _NT_IS_THREADPtr.asFunction<bool Function(ffi.Pointer<NtThread>)>();

  _imp1.NtType nt_thread_get_type() {
    return _nt_thread_get_type();
  }

  late final _nt_thread_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_thread_get_type');
  late final _nt_thread_get_type =
      _nt_thread_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_thread_new:
  ///
  /// Creates a new thread.
  ///
  /// Returns: A new thread
  ffi.Pointer<NtThread> nt_thread_new() {
    return _nt_thread_new();
  }

  late final _nt_thread_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtThread> Function()>>(
          'nt_thread_new');
  late final _nt_thread_new =
      _nt_thread_newPtr.asFunction<ffi.Pointer<NtThread> Function()>();

  /// nt_thread_new_current:
  ///
  /// Creates an instance of %NtThread which represents the thread which called this method.
  ///
  /// Returns: A thread which represents the current thread
  ffi.Pointer<NtThread> nt_thread_new_current() {
    return _nt_thread_new_current();
  }

  late final _nt_thread_new_currentPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtThread> Function()>>(
          'nt_thread_new_current');
  late final _nt_thread_new_current =
      _nt_thread_new_currentPtr.asFunction<ffi.Pointer<NtThread> Function()>();

  /// nt_thread_attach_method:
  /// @self: The thread
  /// @method: The method
  /// @data: The data to pass to the method
  ///
  /// Attaches @method to execute on this thread.
  ///
  /// Returns: A number representing the ID of the method
  int nt_thread_attach_method(
    ffi.Pointer<NtThread> self,
    NtThreadMethod method,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _nt_thread_attach_method(
      self,
      method,
      data,
    );
  }

  late final _nt_thread_attach_methodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<NtThread>, NtThreadMethod,
              ffi.Pointer<ffi.Void>)>>('nt_thread_attach_method');
  late final _nt_thread_attach_method = _nt_thread_attach_methodPtr.asFunction<
      int Function(
          ffi.Pointer<NtThread>, NtThreadMethod, ffi.Pointer<ffi.Void>)>();

  /// nt_thread_detach_method:
  /// @self: The thread
  /// @id: The ID of the method
  ///
  /// Detaches a method by its ID from executing on the thread.
  ///
  /// Returns: The user data passed
  ffi.Pointer<ffi.Void> nt_thread_detach_method(
    ffi.Pointer<NtThread> self,
    int id,
  ) {
    return _nt_thread_detach_method(
      self,
      id,
    );
  }

  late final _nt_thread_detach_methodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NtThread>, ffi.Int)>>('nt_thread_detach_method');
  late final _nt_thread_detach_method = _nt_thread_detach_methodPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtThread>, int)>();

  /// nt_thread_set_main:
  /// @self: The thread
  /// @method: The method
  /// @data: The data to pass to the method
  ///
  /// Sets the thread's main method which executes after the attached methods.
  /// If the thread already has a main, then the old main is returned as a closure.
  ///
  /// Returns: The closure info on the old main and its data.
  NtThreadClosure nt_thread_set_main(
    ffi.Pointer<NtThread> self,
    NtThreadMethod method,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _nt_thread_set_main(
      self,
      method,
      data,
    );
  }

  late final _nt_thread_set_mainPtr = _lookup<
      ffi.NativeFunction<
          NtThreadClosure Function(ffi.Pointer<NtThread>, NtThreadMethod,
              ffi.Pointer<ffi.Void>)>>('nt_thread_set_main');
  late final _nt_thread_set_main = _nt_thread_set_mainPtr.asFunction<
      NtThreadClosure Function(
          ffi.Pointer<NtThread>, NtThreadMethod, ffi.Pointer<ffi.Void>)>();

  late final ffi.Pointer<ffi.Size> _NT_PROCESS_SIZE =
      _lookup<ffi.Size>('NT_PROCESS_SIZE');

  int get NT_PROCESS_SIZE => _NT_PROCESS_SIZE.value;

  set NT_PROCESS_SIZE(int value) => _NT_PROCESS_SIZE.value = value;

  ffi.Pointer<NtProcess> NT_PROCESS(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_PROCESS(
      instance,
    );
  }

  late final _NT_PROCESSPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtProcess> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_PROCESS');
  late final _NT_PROCESS = _NT_PROCESSPtr.asFunction<
      ffi.Pointer<NtProcess> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_PROCESS(
    ffi.Pointer<NtProcess> self,
  ) {
    return _NT_IS_PROCESS(
      self,
    );
  }

  late final _NT_IS_PROCESSPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtProcess>)>>(
          'NT_IS_PROCESS');
  late final _NT_IS_PROCESS =
      _NT_IS_PROCESSPtr.asFunction<bool Function(ffi.Pointer<NtProcess>)>();

  _imp1.NtType nt_process_get_type() {
    return _nt_process_get_type();
  }

  late final _nt_process_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_process_get_type');
  late final _nt_process_get_type =
      _nt_process_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_process_is_current:
  /// @self: Instance of %NtProcess
  ///
  /// Returns whether or not the process is the currently running on the platform
  ///
  /// Returns: %TRUE if @self is the current process, %FALSE if it is not the current process.
  bool nt_process_is_current(
    ffi.Pointer<NtProcess> self,
  ) {
    return _nt_process_is_current(
      self,
    );
  }

  late final _nt_process_is_currentPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtProcess>)>>(
          'nt_process_is_current');
  late final _nt_process_is_current = _nt_process_is_currentPtr
      .asFunction<bool Function(ffi.Pointer<NtProcess>)>();

  /// nt_process_get_platform:
  /// @self: Instance of %NtProcess
  ///
  /// Used for retrieving the platform the process is running on.
  ///
  /// Returns: The platform the process is a part of
  ffi.Pointer<NtPlatform> nt_process_get_platform(
    ffi.Pointer<NtProcess> self,
  ) {
    return _nt_process_get_platform(
      self,
    );
  }

  late final _nt_process_get_platformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtPlatform> Function(
              ffi.Pointer<NtProcess>)>>('nt_process_get_platform');
  late final _nt_process_get_platform = _nt_process_get_platformPtr
      .asFunction<ffi.Pointer<NtPlatform> Function(ffi.Pointer<NtProcess>)>();

  /// nt_process_get_id:
  /// @self: Instance of %NtProcess
  ///
  /// Retrieves the process ID
  ///
  /// Returns: Any number above 0 if the API was able to get a PID.
  int nt_process_get_id(
    ffi.Pointer<NtProcess> self,
  ) {
    return _nt_process_get_id(
      self,
    );
  }

  late final _nt_process_get_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<NtProcess>)>>(
          'nt_process_get_id');
  late final _nt_process_get_id =
      _nt_process_get_idPtr.asFunction<int Function(ffi.Pointer<NtProcess>)>();

  /// nt_process_attach_signal:
  /// @self: Instance of %NtProcess
  /// @hanlder: The handler method to execute
  /// @data: Data to pass to the handler
  ///
  /// Attaches a signal handler with user data to the process.
  /// %nt_process_is_current must return %TRUE in order for signaling to work.
  ///
  /// Returns: The ID of the signal
  int nt_process_attach_signal(
    ffi.Pointer<NtProcess> self,
    NtProcessSignalHandler handler,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _nt_process_attach_signal(
      self,
      handler,
      data,
    );
  }

  late final _nt_process_attach_signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<NtProcess>, NtProcessSignalHandler,
              ffi.Pointer<ffi.Void>)>>('nt_process_attach_signal');
  late final _nt_process_attach_signal =
      _nt_process_attach_signalPtr.asFunction<
          int Function(ffi.Pointer<NtProcess>, NtProcessSignalHandler,
              ffi.Pointer<ffi.Void>)>();

  /// nt_process_detach_signal:
  /// @self: Instance of %NtProcess
  /// @id: The ID of the signal
  ///
  /// Detaches a signal handler with user data to the process.
  /// %nt_process_is_current must return %TRUE in order for signaling to work.
  ///
  /// Returns: The data passed by %nt_process_attach_signal
  ffi.Pointer<ffi.Void> nt_process_detach_signal(
    ffi.Pointer<NtProcess> self,
    int id,
  ) {
    return _nt_process_detach_signal(
      self,
      id,
    );
  }

  late final _nt_process_detach_signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NtProcess>, ffi.Int)>>('nt_process_detach_signal');
  late final _nt_process_detach_signal =
      _nt_process_detach_signalPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtProcess>, int)>();

  /// nt_process_send_signal:
  /// @self: Instance of %NtProcess
  /// @exception: Exception to send
  /// @interrupt: Interrupt to send
  ///
  /// Both @interrupt and @exception cannot be set beyond their none value at the same time.
  /// Both arguments must also not be none so only one can be none. This method triggers a signal
  /// on the target process.
  ///
  /// Returns: %NULL or the data returned.
  ffi.Pointer<ffi.Void> nt_process_send_signal(
    ffi.Pointer<NtProcess> self,
    int exception,
    int interrupt,
  ) {
    return _nt_process_send_signal(
      self,
      exception,
      interrupt,
    );
  }

  late final _nt_process_send_signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtProcess>, ffi.Int32,
              ffi.Int32)>>('nt_process_send_signal');
  late final _nt_process_send_signal = _nt_process_send_signalPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<NtProcess>, int, int)>();

  late final ffi.Pointer<ffi.Size> _NT_DEVICE_SIZE =
      _lookup<ffi.Size>('NT_DEVICE_SIZE');

  int get NT_DEVICE_SIZE => _NT_DEVICE_SIZE.value;

  set NT_DEVICE_SIZE(int value) => _NT_DEVICE_SIZE.value = value;

  ffi.Pointer<NtDevice> NT_DEVICE(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_DEVICE(
      instance,
    );
  }

  late final _NT_DEVICEPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtDevice> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_DEVICE');
  late final _NT_DEVICE = _NT_DEVICEPtr.asFunction<
      ffi.Pointer<NtDevice> Function(ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_DEVICE(
    ffi.Pointer<NtDevice> self,
  ) {
    return _NT_IS_DEVICE(
      self,
    );
  }

  late final _NT_IS_DEVICEPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtDevice>)>>(
          'NT_IS_DEVICE');
  late final _NT_IS_DEVICE =
      _NT_IS_DEVICEPtr.asFunction<bool Function(ffi.Pointer<NtDevice>)>();

  _imp1.NtType nt_device_get_type() {
    return _nt_device_get_type();
  }

  late final _nt_device_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_device_get_type');
  late final _nt_device_get_type =
      _nt_device_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_device_get_query:
  /// @self: Instance of %NtDevice
  ///
  /// Gets the querying information for a device.
  ///
  /// Returns: A device query
  NtDeviceQuery nt_device_get_query(
    ffi.Pointer<NtDevice> self,
  ) {
    return _nt_device_get_query(
      self,
    );
  }

  late final _nt_device_get_queryPtr = _lookup<
          ffi.NativeFunction<NtDeviceQuery Function(ffi.Pointer<NtDevice>)>>(
      'nt_device_get_query');
  late final _nt_device_get_query = _nt_device_get_queryPtr
      .asFunction<NtDeviceQuery Function(ffi.Pointer<NtDevice>)>();
}

/// NtDeviceEnum:
/// @instance: An %NtTypeInstance associated with this
/// @added: Signal for when devices are added
/// @removed: Signal for when devices are removed
/// @count: Method for counting a query
/// @query: Method for performing a query
///
/// Enumerator for hardware devices
class _NtDeviceEnum extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<_imp1.NtSignal> added;

  external ffi.Pointer<_imp1.NtSignal> removed;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<_NtDeviceEnum>, NtDeviceQuery)>> count;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<_imp1.NtList> Function(
              ffi.Pointer<_NtDeviceEnum>, NtDeviceQuery)>> query;
}

/// NtDeviceQuery:
/// @kind: The kind of device
/// @bus: The bus for the device
/// @virt: Boolean value to look for virtual devices
/// @phys: Boolean value to look for physical devices
/// @parameters: Querying parameters
///
/// Querying information for a device
typedef NtDeviceQuery = _NtDeviceQuery;

/// NtDeviceQuery:
/// @kind: The kind of device
/// @bus: The bus for the device
/// @virt: Boolean value to look for virtual devices
/// @phys: Boolean value to look for physical devices
/// @parameters: Querying parameters
///
/// Querying information for a device
class _NtDeviceQuery extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  @ffi.Int32()
  external int bus;

  @ffi.Bool()
  external bool virt;

  @ffi.Bool()
  external bool phys;

  external ffi.Pointer<_imp1.NtTypeArgument> parameters;
}

/// NtDeviceKind:
/// @NT_DEVICE_MISC: Miscellaneous devices
/// @NT_DEVICE_HID: Human interface devices
/// @NT_DEVICE_DISPLAY: Display devices
/// @NT_DEVICE_AUDIO: Audio devices
/// @NT_DEVICE_NET: Networking devices
/// @NT_DEVICE_STORAGE: Storage devices
/// @NT_DEVICE_PLATFORM: Platform devices
///
/// Enum of different kinds of devices.
abstract class _NtDeviceKind {
  static const int NT_DEVICE_MISC = 0;
  static const int NT_DEVICE_HID = 1;
  static const int NT_DEVICE_DISPLAY = 2;
  static const int NT_DEVICE_AUDIO = 3;
  static const int NT_DEVICE_NET = 4;
  static const int NT_DEVICE_STORAGE = 5;
  static const int NT_DEVICE_PLATFORM = 6;
}

/// NtDeviceBus:
/// @NT_DEVICE_BUS_NONE: No bus
/// @NT_DEVICE_BUS_PCI: PCI bus
/// @NT_DEVICE_BUS_USB: USB bus
/// @NT_DEVICE_BUS_AGP: AGP bus
/// @NT_DEVICE_BUS_PCIE: PCI-e bus
/// @NT_DEVICE_BUS_SATA: SATA bus
/// @NT_DEVICE_BUS_IDE: IDE bus
/// @NT_DEVICE_BUS_SCSI: SCSI bus
/// @NT_DEVICE_BUS_IEEE1394: IEEE 1394 (aka. FireWire) bus
/// @NT_DEVICE_BUS_THUNDERBOLT: Thunderbolt bus
/// @NT_DEVICE_BUS_NVME: NVMe bus
/// @NT_DEVICE_BUS_SAS: SAS bus
///
/// Enum of different device buses.
abstract class _NtDeviceBus {
  static const int NT_DEVICE_BUS_NONE = 0;
  static const int NT_DEVICE_BUS_PCI = 1;
  static const int NT_DEVICE_BUS_USB = 2;
  static const int NT_DEVICE_BUS_AGP = 3;
  static const int NT_DEVICE_BUS_PCIE = 4;
  static const int NT_DEVICE_BUS_SATA = 5;
  static const int NT_DEVICE_BUS_IDE = 6;
  static const int NT_DEVICE_BUS_SCSI = 7;
  static const int NT_DEVICE_BUS_IEEE1394 = 8;
  static const int NT_DEVICE_BUS_THUNDERBOLT = 9;
  static const int NT_DEVICE_BUS_NVME = 10;
  static const int NT_DEVICE_BUS_SAS = 11;
}

/// NtDeviceEnum:
/// @instance: An %NtTypeInstance associated with this
/// @added: Signal for when devices are added
/// @removed: Signal for when devices are removed
/// @count: Method for counting a query
/// @query: Method for performing a query
///
/// Enumerator for hardware devices
typedef NtDeviceEnum = _NtDeviceEnum;

/// NtPlatform:
/// @instance: The %NtTypeInstance associated with this
/// @get_os: Method for retrieving the %NtPlatformOS
/// @get_arch: Method for retrieving the %NtPlatformArch
/// @get_device_enum: Method for retrieving the %NtDeviceEnum instance
/// @get_current_process: Method for retrieving the current process
/// @priv: Private data
///
/// An %NtTypeInstance used for platform specific API methods
class _NtPlatform extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<_NtPlatform>)>> get_os;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<_NtPlatform>)>>
      get_arch;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<NtDeviceEnum> Function(ffi.Pointer<_NtPlatform>)>>
      get_device_enum;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<_NtProcess> Function(ffi.Pointer<_NtPlatform>)>>
      get_current_process;

  /// < private >
  external ffi.Pointer<_NtPlatformPrivate> priv;
}

/// NtPlatformOS:
/// @NT_PLATFORM_OS_UNKNOWN: OS could not be determined
/// @NT_PLATFORM_OS_LINUX: Linux
/// @NT_PLATFORM_OS_DARWIN: Apple's Darwin based operating systems
/// @NT_PLATFORM_OS_ANDROID: Android
/// @NT_PLATFORM_OS_WINDOWS: Microsoft Windows
///
/// Enum of different operating systems
abstract class _NtPlatformOS {
  static const int NT_PLATFORM_OS_UNKNOWN = 0;
  static const int NT_PLATFORM_OS_LINUX = 1;
  static const int NT_PLATFORM_OS_DARWIN = 2;
  static const int NT_PLATFORM_OS_ANDROID = 3;
  static const int NT_PLATFORM_OS_WINDOWS = 4;
}

/// NtPlatformArch:
/// @NT_PLATFORM_ARCH_UNKNOWN: CPU architecture could not be determined
/// @NT_PLATFORM_ARCH_AARCH64: 64-bit ARM
/// @NT_PLATFORM_ARCH_ARM: 32-bit ARM
/// @NT_PLATFORM_ARCH_RISCV32: 32-bit RISC-V
/// @NT_PLATFORM_ARCH_RISCV64: 64-bit RISC-V
/// @NT_PLATFORM_ARCH_X86: 32-bit x86 (i386, i486, i686, etc.)
/// @NT_PLATFORM_ARCH_X86_64: 64-bit x86 (amd64)
///
/// Enum of different CPU architectures
abstract class _NtPlatformArch {
  static const int NT_PLATFORM_ARCH_UNKNOWN = 0;
  static const int NT_PLATFORM_ARCH_AARCH64 = 1;
  static const int NT_PLATFORM_ARCH_ARM = 2;
  static const int NT_PLATFORM_ARCH_RISCV32 = 3;
  static const int NT_PLATFORM_ARCH_RISCV64 = 4;
  static const int NT_PLATFORM_ARCH_X86 = 5;
  static const int NT_PLATFORM_ARCH_X86_64 = 6;
}

/// NtProcess:
/// @instance: The %NtTypeInstance associated with this
/// @is_current: Method for determining whether or not the process is the current one
/// @get_id: Retrieve the process ID of this instance of %NtProcess, returns 0 if none exists
/// @send_signal: Method for triggering a signal
/// @priv: Private data
///
/// A process or a thread
class _NtProcess extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<_NtProcess>)>>
      is_current;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<_NtProcess>)>> get_id;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<_NtProcess>, ffi.Int32, ffi.Int32)>> send_signal;

  /// < private >
  external ffi.Pointer<_NtProcessPrivate> priv;
}

/// NtException:
/// @NT_PROCESS_EXCEPTION_NONE: No process exception
/// @NT_PROCESS_EXCEPTION_SEG_VIO: A segment violation occurred
/// @NT_PROCESS_EXCEPTION_ILL_INSTR: An illegal instruction was executed
/// @NT_PROCESS_EXCEPTION_ILL_MATH: An illegal mathematical operation was executed
/// @NT_PROCESS_EXCEPTION_HW_BUS: A bus error was raised
///
/// Enum of different kinds of exceptions
abstract class _NtException {
  static const int NT_PROCESS_EXCEPTION_NONE = 0;
  static const int NT_PROCESS_EXCEPTION_SEG_VIO = 1;
  static const int NT_PROCESS_EXCEPTION_ILL_INSTR = 2;
  static const int NT_PROCESS_EXCEPTION_ILL_MATH = 3;
  static const int NT_PROCESS_EXCEPTION_HW_BUS = 4;
}

/// NtInterrupt:
/// @NT_PROCESS_INTERRUPT_NONE: No process interrupt
/// @NT_PROCESS_INTERRUPT_DBG_STOP: Debugger wants the process to stop
/// @NT_PROCESS_INTERRUPT_DBG_CONT: Debugger wants the process to continue
/// @NT_PROCESS_INTERRUPT_QUIT: Process was told to quit
/// @NT_PROCESS_INTERRUPT_KILL: Process was told to kill
/// @NT_PROCESS_INTERRUPT_EXIT: Process was told to exit
///
/// Enum of different kinds of interrupts
abstract class _NtInterrupt {
  static const int NT_PROCESS_INTERRUPT_NONE = 0;
  static const int NT_PROCESS_INTERRUPT_DBG_STOP = 1;
  static const int NT_PROCESS_INTERRUPT_DBG_CONT = 2;
  static const int NT_PROCESS_INTERRUPT_QUIT = 3;
  static const int NT_PROCESS_INTERRUPT_KILL = 4;
  static const int NT_PROCESS_INTERRUPT_EXIT = 5;
}

class _NtProcessPrivate extends ffi.Opaque {}

class _NtPlatformPrivate extends ffi.Opaque {}

/// NtPlatform:
/// @instance: The %NtTypeInstance associated with this
/// @get_os: Method for retrieving the %NtPlatformOS
/// @get_arch: Method for retrieving the %NtPlatformArch
/// @get_device_enum: Method for retrieving the %NtDeviceEnum instance
/// @get_current_process: Method for retrieving the current process
/// @priv: Private data
///
/// An %NtTypeInstance used for platform specific API methods
typedef NtPlatform = _NtPlatform;

/// NtSignalResult:
/// @NT_SIGNAL_STOP: Stops all signaling
/// @NT_SIGNAL_CONTINUE: Continues signal execution
/// @NT_SIGNAL_RETURN: Makes the process continue after the signal
/// @NT_SIGNAL_QUIT: Quit the process after the signal
///
/// Enums of different results %NtSignalHandler could return
abstract class _NtProcessSignalResult {
  static const int NT_SIGNAL_STOP = 0;
  static const int NT_SIGNAL_CONTINUE = 1;
  static const int NT_SIGNAL_RETURN = 0;
  static const int NT_SIGNAL_QUIT = 2;
}

/// NtSignal:
/// @is_interrupt: Bit value of if the signal was an interrupt
/// @is_exception: Bit value of if the signal was an exception
/// @is_return: Bit value to enable data returning
/// @stack: Pointer to the stack
/// @address: Pointer to the address
/// @exception: Data for an exception
/// @interrupt: Data for an interrupt
///
/// Signaling data
class _NtProcessSignal extends ffi.Opaque {}

/// NtSignalException:
/// @kind: The kind of exception
///
/// Signaling data for an exception
class _NtSignalException extends ffi.Struct {
  @ffi.Int32()
  external int kind;
}

/// NtSignalInterrupt:
/// @kind: The kind of interrupt
///
/// Signaling data for an interrupt
class _NtSignalInterrupt extends ffi.Struct {
  @ffi.Int32()
  external int kind;
}

/// NtSignalReturn:
/// @stack: Stack data
/// @arg0: Data argument 0
/// @arg1: Data argument 1
/// @arg2: Data argument 2
/// @arg3: Data argument 3
///
/// Signaling data to return for when %NT_SIGNAL_RETURN is used
class _NtSignalReturn extends ffi.Struct {
  external ffi.Pointer<ffi.Void> stack;

  external ffi.Pointer<ffi.Void> arg0;

  external ffi.Pointer<ffi.Void> arg1;

  external ffi.Pointer<ffi.Void> arg2;

  external ffi.Pointer<ffi.Void> arg3;
}

/// NtThread:
/// @instance: The %NtTypeInstance associated with this
/// @priv: Private data
///
/// An %NtTypeInstance used for creating threads
class _NtThread extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  /// < private >
  external ffi.Pointer<_NtThreadPrivate> priv;
}

class _NtThreadPrivate extends ffi.Opaque {}

/// NtThreadClosure:
/// @method: The method
/// @data: The user data
///
/// A structure representing closure info on an attached method
class _NtThreadClosure extends ffi.Struct {
  external NtThreadMethod method;

  external ffi.Pointer<ffi.Void> data;
}

/// NtThreadMethod:
/// @thread: The thread calling the method
/// @data: The user data
///
/// Returns: Anything the method wants to return
typedef NtThreadMethod = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<NtThread>, ffi.Pointer<ffi.Void>)>>;

/// NtThread:
/// @instance: The %NtTypeInstance associated with this
/// @priv: Private data
///
/// An %NtTypeInstance used for creating threads
typedef NtThread = _NtThread;

/// NtThreadState:
/// @NT_THREAD_STATE_NONE: The thread has been allocated but it hasn't started
/// @NT_THREAD_STATE_RUNNING: The thread is running
///
/// Enum for different states a thread could be in
abstract class _NtThreadState {
  static const int NT_THREAD_STATE_NONE = 0;
  static const int NT_THREAD_STATE_RUNNING = 1;
}

/// NtThreadClosure:
/// @method: The method
/// @data: The user data
///
/// A structure representing closure info on an attached method
typedef NtThreadClosure = _NtThreadClosure;

/// NtProcess:
/// @instance: The %NtTypeInstance associated with this
/// @is_current: Method for determining whether or not the process is the current one
/// @get_id: Retrieve the process ID of this instance of %NtProcess, returns 0 if none exists
/// @send_signal: Method for triggering a signal
/// @priv: Private data
///
/// A process or a thread
typedef NtProcess = _NtProcess;

/// NtSignalHandler:
/// @proc: The process which was signaled
/// @signal: The signaling data
/// @data: User data to pass to the handler
///
/// A method for handling signals
///
/// Returns: A mask of different %NtSignalResult flags which controls how the process should exit
typedef NtProcessSignalHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<_NtProcess>,
            ffi.Pointer<_NtProcessSignal>, ffi.Pointer<ffi.Void>)>>;

/// NtDevice:
/// @instance: An %NtTypeInstance associated with this
/// @get_query: Method for getting the query information
///
/// A hardware device
class _NtDevice extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  external ffi.Pointer<
          ffi.NativeFunction<NtDeviceQuery Function(ffi.Pointer<_NtDevice>)>>
      get_query;
}

/// NtDevice:
/// @instance: An %NtTypeInstance associated with this
/// @get_query: Method for getting the query information
///
/// A hardware device
typedef NtDevice = _NtDevice;
