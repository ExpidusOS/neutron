// ingore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_name

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:neutron_elemental/bindings.dart' as _imp1;

/// Bindings for Neutron's Runtime
///
class NeutronRuntime {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NeutronRuntime(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NeutronRuntime.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Size> _NT_RUNTIME_CONTEXT_SIZE =
      _lookup<ffi.Size>('NT_RUNTIME_CONTEXT_SIZE');

  int get NT_RUNTIME_CONTEXT_SIZE => _NT_RUNTIME_CONTEXT_SIZE.value;

  set NT_RUNTIME_CONTEXT_SIZE(int value) =>
      _NT_RUNTIME_CONTEXT_SIZE.value = value;

  ffi.Pointer<NtRuntimeContext> NT_RUNTIME_CONTEXT(
    ffi.Pointer<_imp1.NtTypeInstance> instance,
  ) {
    return _NT_RUNTIME_CONTEXT(
      instance,
    );
  }

  late final _NT_RUNTIME_CONTEXTPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NtRuntimeContext> Function(
              ffi.Pointer<_imp1.NtTypeInstance>)>>('NT_RUNTIME_CONTEXT');
  late final _NT_RUNTIME_CONTEXT = _NT_RUNTIME_CONTEXTPtr.asFunction<
      ffi.Pointer<NtRuntimeContext> Function(
          ffi.Pointer<_imp1.NtTypeInstance>)>();

  bool NT_IS_RUNTIME_CONTEXT(
    ffi.Pointer<NtRuntimeContext> self,
  ) {
    return _NT_IS_RUNTIME_CONTEXT(
      self,
    );
  }

  late final _NT_IS_RUNTIME_CONTEXTPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<NtRuntimeContext>)>>(
      'NT_IS_RUNTIME_CONTEXT');
  late final _NT_IS_RUNTIME_CONTEXT = _NT_IS_RUNTIME_CONTEXTPtr.asFunction<
      bool Function(ffi.Pointer<NtRuntimeContext>)>();

  _imp1.NtType nt_runtime_context_get_type() {
    return _nt_runtime_context_get_type();
  }

  late final _nt_runtime_context_get_typePtr =
      _lookup<ffi.NativeFunction<_imp1.NtType Function()>>(
          'nt_runtime_context_get_type');
  late final _nt_runtime_context_get_type =
      _nt_runtime_context_get_typePtr.asFunction<_imp1.NtType Function()>();

  /// nt_runtime_context_get_renderer:
  /// @self: The context instance
  ///
  /// Gets the renderer being used for the runtime
  ///
  /// Returns: A renderer instance
  ffi.Pointer<ffi.Int> nt_runtime_context_get_renderer(
    ffi.Pointer<NtRuntimeContext> self,
  ) {
    return _nt_runtime_context_get_renderer(
      self,
    );
  }

  late final _nt_runtime_context_get_rendererPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int> Function(ffi.Pointer<NtRuntimeContext>)>>(
      'nt_runtime_context_get_renderer');
  late final _nt_runtime_context_get_renderer =
      _nt_runtime_context_get_rendererPtr.asFunction<
          ffi.Pointer<ffi.Int> Function(ffi.Pointer<NtRuntimeContext>)>();
}

/// NtRuntimeContext:
/// @instance: The %NtTypeInstance associated with this
/// @priv: Private data
///
/// Context for the runtime
class _NtRuntimeContext extends ffi.Struct {
  external _imp1.NtTypeInstance instance;

  /// < private >
  external ffi.Pointer<_NtRuntimeContextPrivate> priv;
}

class _NtRuntimeContextPrivate extends ffi.Opaque {}

/// NtRuntimeContext:
/// @instance: The %NtTypeInstance associated with this
/// @priv: Private data
///
/// Context for the runtime
typedef NtRuntimeContext = _NtRuntimeContext;
