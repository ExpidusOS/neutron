// ingore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_name

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for Neutron's Shimmy
///
class NeutronShimmy {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NeutronShimmy(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NeutronShimmy.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// nt_shimmy_bind:
  /// @lib: Library name
  /// @method: Method name
  /// @handler: Method handler to execute
  ///
  /// Binds a shim with Shimmy.
  ///
  /// Returns: The ID of the bounded shim.
  int nt_shimmy_bind(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> method,
    NtShimMethod handler,
  ) {
    return _nt_shimmy_bind(
      lib,
      method,
      handler,
    );
  }

  late final _nt_shimmy_bindPtr = _lookup<
      ffi.NativeFunction<
          NtShim Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              NtShimMethod)>>('nt_shimmy_bind');
  late final _nt_shimmy_bind = _nt_shimmy_bindPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, NtShimMethod)>();

  /// nt_shimmy_find:
  /// @lib: Library name
  /// @method: Method name
  ///
  /// Finds a shim's ID by its library and method name.
  /// Returns: A shim ID
  int nt_shimmy_find(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> method,
  ) {
    return _nt_shimmy_find(
      lib,
      method,
    );
  }

  late final _nt_shimmy_findPtr = _lookup<
      ffi.NativeFunction<
          NtShim Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('nt_shimmy_find');
  late final _nt_shimmy_find = _nt_shimmy_findPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// nt_shimmy_get_shim:
  /// @id: ID of the shim
  ///
  /// Looks for the shim binding and returns it.
  /// Returns: A shim binding
  ffi.Pointer<NtShimBinding> nt_shimmy_get_shim(
    int id,
  ) {
    return _nt_shimmy_get_shim(
      id,
    );
  }

  late final _nt_shimmy_get_shimPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtShimBinding> Function(NtShim)>>(
          'nt_shimmy_get_shim');
  late final _nt_shimmy_get_shim = _nt_shimmy_get_shimPtr
      .asFunction<ffi.Pointer<NtShimBinding> Function(int)>();

  /// nt_shimmy_unbind:
  /// @id: ID of the shim
  ///
  /// Unbinds a shim by its ID.
  void nt_shimmy_unbind(
    int id,
  ) {
    return _nt_shimmy_unbind(
      id,
    );
  }

  late final _nt_shimmy_unbindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NtShim)>>(
          'nt_shimmy_unbind');
  late final _nt_shimmy_unbind =
      _nt_shimmy_unbindPtr.asFunction<void Function(int)>();

  /// nt_shimmy_get_reg:
  ///
  /// Gets the registry address.
  /// This is used internally for binding into a child process.
  ffi.Pointer<ffi.Void> nt_shimmy_get_reg() {
    return _nt_shimmy_get_reg();
  }

  late final _nt_shimmy_get_regPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'nt_shimmy_get_reg');
  late final _nt_shimmy_get_reg =
      _nt_shimmy_get_regPtr.asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// nt_shimmy_exec:
  /// @proc: The process to run a shim on
  /// @lib: Library name
  /// @method: Method name
  /// @data: The data to pass
  ///
  /// Executes a shim
  ///
  /// Returns: Data returned from execution.
  ffi.Pointer<ffi.Void> nt_shimmy_exec(
    ffi.Pointer<NtProcess> proc,
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> method,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _nt_shimmy_exec(
      proc,
      lib,
      method,
      data,
    );
  }

  late final _nt_shimmy_execPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NtProcess>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('nt_shimmy_exec');
  late final _nt_shimmy_exec = _nt_shimmy_execPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<NtProcess>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>)>();
}

/// NtShimBinding:
/// @lib: Library name
/// @method: Method name
/// @handler: Method handler to execute
/// @id: The ID of the bounded shim
///
/// A structure for a shim binding
class _NtShimBinding extends ffi.Struct {
  external ffi.Pointer<ffi.Char> lib;

  external ffi.Pointer<ffi.Char> method;

  external NtShimMethod handler;

  @NtShim()
  external int id;
}

/// NtShimBinding:
/// @binding: The binding which was executed
/// @data: The data to pass
///
/// Method binding handler for a shim
///
/// Returns: The result of the binded method
typedef NtShimMethod = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<_NtShimBinding>, ffi.Pointer<ffi.Void>)>>;

/// NtShim:
///
/// ID of a bounded shim
typedef NtShim = ffi.UintPtr;

/// NtShimBinding:
/// @lib: Library name
/// @method: Method name
/// @handler: Method handler to execute
/// @id: The ID of the bounded shim
///
/// A structure for a shim binding
typedef NtShimBinding = _NtShimBinding;

/// NtProcess:
/// @instance: The %NtTypeInstance associated with this
/// @is_current: Method for determining whether or not the process is the current one
/// @get_id: Retrieve the process ID of this instance of %NtProcess, returns 0 if none exists
/// @send_signal: Method for triggering a signal
/// @priv: Private data
///
/// A process or a thread
typedef NtProcess = _NtProcess;

/// NtProcess:
/// @instance: The %NtTypeInstance associated with this
/// @is_current: Method for determining whether or not the process is the current one
/// @get_id: Retrieve the process ID of this instance of %NtProcess, returns 0 if none exists
/// @send_signal: Method for triggering a signal
/// @priv: Private data
///
/// A process or a thread
class _NtProcess extends ffi.Struct {
  external NtTypeInstance instance;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<_NtProcess>)>>
      is_current;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<_NtProcess>)>> get_id;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<_NtProcess>, ffi.Int32, ffi.Int32)>> send_signal;

  /// < private >
  external ffi.Pointer<_NtProcessPrivate> priv;
}

/// NtTypeInstance:
/// @type: The type the instance was allocated for
/// @data_size: The total size of %NtTypeInstance
/// @ref_count: Number of references this instance has
/// @prev: The previous level instance this is tied to
///
/// Instance of a type
typedef NtTypeInstance = _NtTypeInstance;

/// NtTypeInstance:
/// @type: The type the instance was allocated for
/// @data_size: The total size of %NtTypeInstance
/// @ref_count: Number of references this instance has
/// @prev: The previous level instance this is tied to
///
/// Instance of a type
class _NtTypeInstance extends ffi.Struct {
  @NtType()
  external int type;

  @ffi.Size()
  external int data_size;

  @ffi.Size()
  external int ref_count;

  external ffi.Pointer<_NtTypeInstance> prev;
}

/// NtType:
///
/// ID of a registered type
typedef NtType = ffi.Uint32;

/// NtException:
/// @NT_PROCESS_EXCEPTION_NONE: No process exception
/// @NT_PROCESS_EXCEPTION_SEG_VIO: A segment violation occurred
/// @NT_PROCESS_EXCEPTION_ILL_INSTR: An illegal instruction was executed
/// @NT_PROCESS_EXCEPTION_ILL_MATH: An illegal mathematical operation was executed
/// @NT_PROCESS_EXCEPTION_HW_BUS: A bus error was raised
///
/// Enum of different kinds of exceptions
abstract class _NtException {
  static const int NT_PROCESS_EXCEPTION_NONE = 0;
  static const int NT_PROCESS_EXCEPTION_SEG_VIO = 1;
  static const int NT_PROCESS_EXCEPTION_ILL_INSTR = 2;
  static const int NT_PROCESS_EXCEPTION_ILL_MATH = 3;
  static const int NT_PROCESS_EXCEPTION_HW_BUS = 4;
}

/// NtInterrupt:
/// @NT_PROCESS_INTERRUPT_NONE: No process interrupt
/// @NT_PROCESS_INTERRUPT_DBG_STOP: Debugger wants the process to stop
/// @NT_PROCESS_INTERRUPT_DBG_CONT: Debugger wants the process to continue
/// @NT_PROCESS_INTERRUPT_QUIT: Process was told to quit
/// @NT_PROCESS_INTERRUPT_KILL: Process was told to kill
/// @NT_PROCESS_INTERRUPT_EXIT: Process was told to exit
///
/// Enum of different kinds of interrupts
abstract class _NtInterrupt {
  static const int NT_PROCESS_INTERRUPT_NONE = 0;
  static const int NT_PROCESS_INTERRUPT_DBG_STOP = 1;
  static const int NT_PROCESS_INTERRUPT_DBG_CONT = 2;
  static const int NT_PROCESS_INTERRUPT_QUIT = 3;
  static const int NT_PROCESS_INTERRUPT_KILL = 4;
  static const int NT_PROCESS_INTERRUPT_EXIT = 5;
}

class _NtProcessPrivate extends ffi.Opaque {}

const int NT_SHIM_NONE = 0;
