// ingore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_name

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for Neutron's Shimmy
///
class NeutronShimmy {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NeutronShimmy(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NeutronShimmy.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// nt_shimmy_bind:
  /// @lib: Library name
  /// @method: Method name
  /// @handler: Method handler to execute
  ///
  /// Binds a shim with Shimmy.
  ///
  /// Returns: The ID of the bounded shim.
  int nt_shimmy_bind(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> method,
    NtShimMethod handler,
  ) {
    return _nt_shimmy_bind(
      lib,
      method,
      handler,
    );
  }

  late final _nt_shimmy_bindPtr = _lookup<
      ffi.NativeFunction<
          NtShim Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              NtShimMethod)>>('nt_shimmy_bind');
  late final _nt_shimmy_bind = _nt_shimmy_bindPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, NtShimMethod)>();

  /// nt_shimmy_find:
  /// @lib: Library name
  /// @method: Method name
  ///
  /// Finds a shim's ID by its library and method name.
  /// Returns: A shim ID
  int nt_shimmy_find(
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> method,
  ) {
    return _nt_shimmy_find(
      lib,
      method,
    );
  }

  late final _nt_shimmy_findPtr = _lookup<
      ffi.NativeFunction<
          NtShim Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('nt_shimmy_find');
  late final _nt_shimmy_find = _nt_shimmy_findPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// nt_shimmy_get_shim:
  /// @id: ID of the shim
  ///
  /// Looks for the shim binding and returns it.
  /// Returns: A shim binding
  ffi.Pointer<NtShimBinding> nt_shimmy_get_shim(
    int id,
  ) {
    return _nt_shimmy_get_shim(
      id,
    );
  }

  late final _nt_shimmy_get_shimPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NtShimBinding> Function(NtShim)>>(
          'nt_shimmy_get_shim');
  late final _nt_shimmy_get_shim = _nt_shimmy_get_shimPtr
      .asFunction<ffi.Pointer<NtShimBinding> Function(int)>();

  /// nt_shimmy_unbind:
  /// @id: ID of the shim
  ///
  /// Unbinds a shim by its ID.
  void nt_shimmy_unbind(
    int id,
  ) {
    return _nt_shimmy_unbind(
      id,
    );
  }

  late final _nt_shimmy_unbindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NtShim)>>(
          'nt_shimmy_unbind');
  late final _nt_shimmy_unbind =
      _nt_shimmy_unbindPtr.asFunction<void Function(int)>();

  /// nt_shimmy_get_reg:
  ///
  /// Gets the registry address.
  /// This is used internally for binding into a child process.
  ffi.Pointer<ffi.Void> nt_shimmy_get_reg() {
    return _nt_shimmy_get_reg();
  }

  late final _nt_shimmy_get_regPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'nt_shimmy_get_reg');
  late final _nt_shimmy_get_reg =
      _nt_shimmy_get_regPtr.asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// nt_shimmy_exec:
  /// @proc: The process to run a shim on
  /// @lib: Library name
  /// @method: Method name
  /// @data: The data to pass
  ///
  /// Executes a shim
  ///
  /// Returns: Data returned from execution.
  ffi.Pointer<ffi.Void> nt_shimmy_exec(
    ffi.Pointer<ffi.Int> proc,
    ffi.Pointer<ffi.Char> lib,
    ffi.Pointer<ffi.Char> method,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _nt_shimmy_exec(
      proc,
      lib,
      method,
      data,
    );
  }

  late final _nt_shimmy_execPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('nt_shimmy_exec');
  late final _nt_shimmy_exec = _nt_shimmy_execPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>)>();
}

/// NtShimBinding:
/// @lib: Library name
/// @method: Method name
/// @handler: Method handler to execute
/// @id: The ID of the bounded shim
///
/// A structure for a shim binding
class _NtShimBinding extends ffi.Struct {
  external ffi.Pointer<ffi.Char> lib;

  external ffi.Pointer<ffi.Char> method;

  external NtShimMethod handler;

  @NtShim()
  external int id;
}

/// NtShimBinding:
/// @binding: The binding which was executed
/// @data: The data to pass
///
/// Method binding handler for a shim
///
/// Returns: The result of the binded method
typedef NtShimMethod = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<_NtShimBinding>, ffi.Pointer<ffi.Void>)>>;

/// NtShim:
///
/// ID of a bounded shim
typedef NtShim = ffi.Int;

/// NtShimBinding:
/// @lib: Library name
/// @method: Method name
/// @handler: Method handler to execute
/// @id: The ID of the bounded shim
///
/// A structure for a shim binding
typedef NtShimBinding = _NtShimBinding;

const int NT_SHIM_NONE = 0;
