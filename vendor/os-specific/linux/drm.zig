const std = @import("std");
const Build = std.Build;
const ScanProtocolsStep = @import("zig/zig-wayland/build.zig").ScanProtocolsStep;
const Drm = @This();

const version = std.builtin.Version {
  .major = 2,
  .minor = 4,
  .patch = 115,
};

gen_step: Build.Step,
gen_header: Build.GeneratedFile,
lib: *Build.CompileStep,

fn getPath(comptime suffix: []const u8) []const u8 {
  if (suffix[0] != '/') @compileError("path requires an absolute path!");
  return comptime blk: {
    const root_dir = std.fs.path.dirname(@src().file) orelse ".";
    break :blk root_dir ++ "/libs/drm" ++ suffix;
  };
}

pub const DrmOptions = struct {
  builder: *Build,
  target: std.zig.CrossTarget,
  optimize: std.builtin.Mode,
};

fn other_vendor(comptime name: []const u8, allocator: std.mem.Allocator, input: []const u8, output: *std.ArrayList(u8)) !void {
  var iter = std.mem.split(u8, input, "\n#define DRM_FORMAT_MOD_" ++ name ++ "_");

  while (iter.next()) |chunk| {
    var index = std.mem.indexOf(u8, chunk, " ");
    if (index == null) break;

    const index2 = std.mem.indexOf(u8, chunk, "\t");
    if (index2 != null) {
      if (index2.? < index.?) index = index2;
    }

    const value = try allocator.alloc(u8, index.?);
    defer allocator.free(value);

    for (value[0..index.?], 0..) |*v, x|
      v.* = chunk[x];

    if (std.mem.startsWith(u8, value, "/*")) continue;
    if (std.mem.endsWith(u8, value, ")")) continue;
    if (std.mem.endsWith(u8, value, ",")) continue;

    if (std.mem.eql(u8, name, "ARM") and
      (std.mem.eql(u8, value, "TYPE_AFBC") or std.mem.eql(u8, value, "TYPE_MISC")
        or std.mem.eql(u8, value, "TYPE_AFRC"))) continue;

    try output.appendSlice("  { DRM_MODIFIER(" ++ name ++ ", ");
    try output.appendSlice(value);
    try output.appendSlice(", ");
    try output.appendSlice(value);
    try output.appendSlice(") },\n");
  }
}

fn gen_step_make(step: *Build.Step, prog_node: *std.Progress.Node) !void {
  _ = prog_node;
  const self = @fieldParentPtr(Drm, "gen_step", step);
  const b = step.owner;

  var man = b.cache.obtain();
  defer man.deinit();

  const input_file = try std.fs.openFileAbsolute(getPath("/include/drm/drm_fourcc.h"), .{});
  defer input_file.close();

  const input_reader = input_file.reader();
  const input = try input_reader.readAllAlloc(b.allocator, (try input_file.metadata()).size());
  defer b.allocator.free(input);

  var intel_iter = std.mem.split(u8, input, "\n#define I915_FORMAT_MOD_");

  var output = std.ArrayList(u8).init(b.allocator);
  defer output.deinit();

  try output.appendSlice(
    \\/* AUTOMATICALLY GENERATED by gen_table_fourcc.py. You should modify
    \\   that script instead of adding here entries manually! */
    \\static const struct drmFormatModifierInfo drm_format_modifier_table[] = {
    \\  { DRM_MODIFIER_INVALID(NONE, INVALID) },
    \\  { DRM_MODIFIER_LINEAR(NONE, LINEAR) },
    \\
  );

  while (intel_iter.next()) |chunk| {
    var index = std.mem.indexOf(u8, chunk, " ");
    if (index == null) break;

    const index2 = std.mem.indexOf(u8, chunk, "\t");
    if (index2 != null) {
      if (index2.? < index.?) index = index2;
    }

    const value = try b.allocator.alloc(u8, index.?);
    defer b.allocator.free(value);

    for (value[0..index.?], 0..) |*v, x|
      v.* = chunk[x];

    if (std.mem.startsWith(u8, value, "/*")) continue;

    try output.appendSlice("  { DRM_MODIFIER_INTEL(");
    try output.appendSlice(value);
    try output.appendSlice(", ");
    try output.appendSlice(value);
    try output.appendSlice(") },\n");
  }

  try other_vendor("ARM", b.allocator, input, &output);
  try other_vendor("SAMSUNG", b.allocator, input, &output);
  try other_vendor("QCOM", b.allocator, input, &output);
  try other_vendor("VIVANTE", b.allocator, input, &output);
  try other_vendor("NVIDIA", b.allocator, input, &output);
  try other_vendor("BROADCOM", b.allocator, input, &output);
  try other_vendor("ALLWINNER", b.allocator, input, &output);

  try output.appendSlice(
    \\};
    \\
    \\static const struct drmFormatModifierVendorInfo drm_format_modifier_vendor_table[] = {
  );

  var vendor_iter = std.mem.split(u8, input, "\n#define DRM_FORMAT_MOD_VENDOR_");

  while (vendor_iter.next()) |chunk| {
    var index = std.mem.indexOf(u8, chunk, " ");
    if (index == null) break;

    const index2 = std.mem.indexOf(u8, chunk, "\t");
    if (index2 != null) {
      if (index2.? < index.?) index = index2;
    }

    const value = try b.allocator.alloc(u8, index.?);
    defer b.allocator.free(value);

    for (value[0..index.?], 0..) |*v, x|
      v.* = chunk[x];

    if (std.mem.startsWith(u8, value, "/*")) continue;

    try output.appendSlice("  { DRM_FORMAT_MOD_VENDOR_");
    try output.appendSlice(value);
    try output.appendSlice(", \"");
    try output.appendSlice(value);
    try output.appendSlice("\" },\n");
  }

  try output.appendSlice("};");

  man.hash.addBytes(output.items);

  if (try step.cacheHit(&man)) {
    const digest = man.final();
    const sub_path = try b.cache_root.join(b.allocator, &.{
      "o", &digest, "generated_static_table_fourcc.h",
    });
    const sub_path_dirname = std.fs.path.dirname(sub_path).?;

    self.gen_header.path = sub_path;
    self.lib.addIncludePath(sub_path_dirname);
    return;
  }

  const digest = man.final();
  const sub_path = try std.fs.path.join(b.allocator, &.{ "o", &digest, "generated_static_table_fourcc.h" });
  const sub_path_dirname = std.fs.path.dirname(sub_path).?;

  b.cache_root.handle.makePath(sub_path_dirname) catch |err| {
    return step.fail("unable to make path '{}{s}': {s}", .{
      b.cache_root, sub_path_dirname, @errorName(err),
    });
  };

  b.cache_root.handle.writeFile(sub_path, output.items) catch |err| {
    return step.fail("unable to write file '{}{s}': {s}", .{
      b.cache_root, sub_path, @errorName(err),
    });
  };


  self.gen_header.path = try b.cache_root.join(b.allocator, &.{sub_path});
  self.lib.addIncludePath(sub_path_dirname);
  try man.writeManifest();
}

pub fn init(options: DrmOptions) !*Drm {
  const self = try options.builder.allocator.create(Drm);
  self.* = .{
    .lib = if (options.target.getObjectFormat() == .wasm)
      options.builder.addStaticLibrary(.{
        .name = "drm",
        .root_source_file = .{
          .path = getPath("/../../zig/zig-libdrm/src/libdrm.zig"),
        },
        .version = version,
        .target = options.target,
        .optimize = options.optimize,
      })
    else
      options.builder.addSharedLibrary(.{
        .name = "drm",
        .root_source_file = .{
          .path = getPath("/../../zig/zig-libdrm/src/libdrm.zig"),
        },
        .version = version,
        .target = options.target,
        .optimize = options.optimize,
      }),
    .gen_step = Build.Step.init(.{
      .id = .custom,
      .name = "Generate generated_static_table_fourcc.h",
      .owner = options.builder,
      .makeFn = gen_step_make,
    }),
    .gen_header = Build.GeneratedFile {
      .step = &self.gen_step,
    },
  };

  var prog = std.Progress {};
  var node = prog.start("Generate generated_static_table_fourcc.h", 0);
  defer node.end();
  node.activate();
  try gen_step_make(&self.gen_step, node);

  self.lib.step.dependOn(&self.gen_step);

  self.lib.linkLibC();
  self.lib.addIncludePath(getPath("/include/drm"));

  self.lib.defineCMacro("MAJOR_IN_SYSMACROS", "true");
  self.lib.defineCMacro("HAVE_OPEN_MEMSTREAM", "true");

  self.lib.addCSourceFiles(&[_][]const u8 {
    getPath("/xf86drm.c"),
    getPath("/xf86drmHash.c"),
    getPath("/xf86drmRandom.c"),
    getPath("/xf86drmSL.c"),
    getPath("/xf86drmMode.c"),
  }, &[_][]const u8{});
  return self;
}

pub fn createModule(self: *Drm) *Build.Module {
  return self.lib.step.owner.addModule("libdrm", .{
    .source_file = self.lib.root_src.?,
  });
}

pub fn link(self: *Drm, cs: *Build.CompileStep) void {
  cs.linkLibrary(self.lib);
  cs.addIncludePath(getPath("/include/drm"));
  cs.addIncludePath(getPath("/"));
}

pub fn install(self: *Drm) void {
  self.lib.install();
}
